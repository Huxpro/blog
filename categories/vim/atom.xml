<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: vim | Bits, Bytes, and Words]]></title>
  <link href="https://blog.jez.io/categories/vim/atom.xml" rel="self"/>
  <link href="https://blog.jez.io/"/>
  <updated>2017-07-16T18:13:38-04:00</updated>
  <id>https://blog.jez.io/</id>
  <author>
    <name><![CDATA[Jake Zimmerman]]></name>
    <email><![CDATA[jake@zimmerman.io]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Haskell Development with Neovim]]></title>
    <link href="https://blog.jez.io/2017/07/16/haskell-development-with-neovim/"/>
    <updated>2017-07-16T14:45:31-04:00</updated>
    <id>https://blog.jez.io/2017/07/16/haskell-development-with-neovim</id>
    <content type="html"><![CDATA[<p>Configuring an editor for a new language is a double-edged sword: it&rsquo;s intensely
satisfying when done, but takes time away from diving into the language itself!
After using Haskell for a little over a year, I&rsquo;ve settled on a high-quality set
of editor plugins. They&rsquo;re simple, powerful, and all play nicely together.</p>

<!-- more -->


<h2>Requirements</h2>

<p>I use <a href="https://www.haskellstack.org/">Haskell Stack</a> exclusively for managing GHC versions, installing
packages, and building projects. Stack&rsquo;s goal is reproducible builds, which
means that if two different people have the same code and both run <code>stack
build</code>, they both get the same result. Since builds are reproducible, Stack can
cache pretty aggressively to save time in the future<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>. I never have to
invoke <code>ghc</code> or <code>cabal</code> manually; Stack handles everything.</p>

<p>I also use <a href="https://github.com/neovim/neovim">Neovim</a>, rather than normal Vim. Usually my justification
for using it is more philosophical than technical, but with my Haskell setup
it&rsquo;s actually a requirement (we&rsquo;ll see why further on). Neovim is quite stable,
works as a drop-in replacement for Vim, yet brings new features<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>. I love
Neovim, and I&rsquo;ll be writing more about why in a future post.</p>

<!-- TODO(jez): Update with link to Neovim post -->


<h2>Overview</h2>

<p>We&rsquo;re going to move in order of increasing complexity. That said, even the most
&ldquo;complex&rdquo; plugin here is actually quite painless to set up. By the end, we&rsquo;ll
have a complete development experience! Coming up:</p>

<ul>
<li>syntax highlighting &amp; indentation (<a href="https://github.com/neovimhaskell/haskell-vim">haskell-vim</a>)</li>
<li>auto-formatting &amp; style (<a href="https://github.com/commercialhaskell/hindent">hindent</a>, <a href="https://github.com/jaspervdj/stylish-haskell">stylish-haskell</a>)</li>
<li>quickfix and sign column icons (using <a href="https://github.com/w0rp/ale">ale</a>) for:

<ul>
<li>linter style suggestions (hlint)</li>
<li>compiler errors and warnings (ghc-mod)</li>
</ul>
</li>
<li>Type inspection, REPL integration, and <strong>more!</strong> (<a href="https://github.com/parsonsmatt/intero-neovim">intero-neovim</a>)</li>
</ul>


<p>If you just want to browse the final configuration, <a href="https://gist.github.com/jez/ed4dc673385c82243805a19797a37ff6">here&rsquo;s a Gist</a>.</p>

<!-- TODO(jez) Demonstrate everything with an asciicast -->


<h2>Syntax Highlighting &amp; Indentation</h2>

<ul>
<li><strong>Plugin</strong>: <a href="https://github.com/neovimhaskell/haskell-vim">haskell-vim</a><sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup></li>
</ul>


<p>Vim&rsquo;s default Haskell filetype plugin is pretty lack luster. Everything is blue,
except for strings which are colored like comments and keywords which are
colored like constants. Indentation is wonky in some edge cases, and isn&rsquo;t
configurable.</p>

<p>This plugin corrects all that. It&rsquo;s the filetype plugin for Haskell that
<strong>should</strong> ship with Vim.</p>

<p><code>haskell-vim</code> lets me configure certain parts of the indentation, too. These are
my indentation settings. Note that the last setting only works because I&rsquo;ve
merged <a href="https://github.com/neovimhaskell/haskell-vim/pull/98">this PR</a> locally.</p>

<pre><code class="vim neovimhaskell/haskell-vim">" Align 'then' two spaces after 'if'
let g:haskell_indent_if = 2
" Indent 'where' block two spaces under previous body
let g:haskell_indent_before_where = 2
" Allow a second case indent style (see haskell-vim README)
let g:haskell_indent_case_alternative = 1
" Correct bug with aggressive let indentation
let g:haskell_indent_let_no_in = 0
</code></pre>

<h2>Auto-formatting and Indentation</h2>

<ul>
<li><strong>Plugin</strong>: <a href="https://github.com/alx741/vim-hindent">vim-hindent</a></li>
<li><strong>Tool</strong>: <code>stack install hindent</code></li>
<li><strong>Tool</strong>: <code>stack install stylish-haskell</code></li>
</ul>


<p>For small projects, I like using my own, personal style. However, for larger
projects it&rsquo;s a burden to ask contributors to learn my personal style. In these
cases, tools come into play.</p>

<p><code>go fmt</code> famously solved this problem for Golang by building the formatting tool
into the compiler. For Haskell, there&rsquo;s <a href="https://github.com/commercialhaskell/hindent">hindent</a><sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>. <code>hindent</code> can be
installed through Stack, and <code>vim-hindent</code> shims it.</p>

<p>But I said I&rsquo;m partial to my own style in personal projects. There&rsquo;s another
Haskell formatter that&rsquo;s much less invasive: <a href="https://github.com/jaspervdj/stylish-haskell">stylish-haskell</a>. It basically
only works with <code>import</code>s, <code>case</code> branches, and record fields, aligning them
vertically.</p>

<p>With these three tools, I can pick the right hammer for the job:</p>

<ul>
<li><strong>Bare hands</strong>: manually control the style myself</li>
<li><strong>Normal hammer</strong>: run <code>stylish-haskell</code> only</li>
<li><strong>Sledgehammer</strong>: run <code>hindent</code> only</li>
<li><strong>Sledgehammer, then band-aid</strong>: run <code>hindent</code>, then <code>stylish-haskell</code></li>
</ul>


<p>Here&rsquo;s the config that gets them to play nicely together:</p>

<pre><code class="vim hindent, vim-hindent, and stylish-haskell">" Indenting on save is too aggressive for me
let g:hindent_on_save = 0

" Helper function, called below with mappings
function! HaskellFormat(which) abort
  if a:which ==# 'hindent' || a:which ==# 'both'
    :Hindent
  endif
  if a:which ==# 'stylish' || a:which ==# 'both'
    silent! exe 'undojoin'
    silent! exe 'keepjumps %!stylish-haskell'
  endif
endfunction

" Key bindings
augroup haskellStylish
  au!
  " Just hindent
  au FileType haskell nnoremap &lt;leader&gt;hi :Hindent&lt;CR&gt;
  " Just stylish-haskell
  au FileType haskell nnoremap &lt;leader&gt;hs :call HaskellFormat('stylish')&lt;CR&gt;
  " First hindent, then stylish-haskell
  au FileType haskell nnoremap &lt;leader&gt;hf :call HaskellFormat('both')&lt;CR&gt;
augroup END
</code></pre>

<h2>Quickfix &amp; Sign Columns</h2>

<ul>
<li><strong>Plugin</strong>: <a href="https://github.com/w0rp/ale">ale</a></li>
<li><strong>Tool</strong>: <code>stack install hlint</code></li>
<li><strong>Tool</strong>: <code>stack build ghc-mod</code></li>
</ul>


<p>This is where the Neovim dependency starts to creep up, though Vim 8 is an
acceptable alternative for now. ALE stands for &ldquo;Asynchronous Lint Engine.&rdquo; It&rsquo;s
like Syntastic, but asynchronous<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup>.</p>

<p>There are a number of Haskell engines that ship with ALE. For example, it will
be able to show errors if all that&rsquo;s installed is Stack. My preferred tools to
use for Haskell with ALE are <code>hlint</code> and <code>ghc-mod</code>.</p>

<ul>
<li><code>hlint</code> is a linter for Haskell. It warns about silly things like <code>if x then
True else False</code>.</li>
<li><code>ghc-mod</code> is a tool that can check files for compiler errors</li>
</ul>


<p>Note that we want to <strong>stack build</strong> ghc-mod, not stack install it. The former
ensures that <code>ghc-mod</code> is local to the current stack project, so that the
version never gets out of sync with your project.</p>

<p>Once we&rsquo;ve installed all these programs, the setup is minimal. We&rsquo;ll be able to
see <code>hlint</code> and <code>ghc-mod</code> errors in our quickfix window right away.</p>

<pre><code class="vim ALE setup">let g:ale_linters.haskell = ['stack-ghc-mod', 'hlint']
</code></pre>

<h2>Intero: The Pièce de Résistance</h2>

<ul>
<li><strong>Plugin</strong>: <a href="https://github.com/parsonsmatt/intero-neovim">intero-neovim</a></li>
</ul>


<p>Intero is a complete development program for Haskell. Probably the best way to
introduce it is with this asciicast:</p>

<p align="center">
  <a href="https://asciinema.org/a/128416">
    <img
      width="700px"
      alt="Intero for Neovim asciicast"
      src="https://asciinema.org/a/128416.png">
  </a>
</p>


<p>Intero is designed for stack, sets itself up automatically, has point-and-click
type information, and lets you jump to definitions. On top of it all, it uses
Neovim to communicate back and forth with a terminal buffer so that you get a
GHCi buffer <strong>right inside Neovim</strong>.</p>

<p>Developing with the REPL in mind helps me write code better. Only top-level
bindings are exposed in the REPL, so I write more small, testable functions.
See here for more reasons <a href="http://chrisdone.com/posts/haskell-repl">why the REPL is awesome</a>.</p>

<p>On top of providing access to the REPL, Intero provides about a dozen
convenience commands that shell out to the REPL backend. Being able to reload
your code in the REPL&mdash;from Vim, with a single keystroke!&mdash;is a huge boon when
developing.</p>

<p>Intero sets up no mappings by default, so here are mine. I also flip two config
variables to make Intero a little faster:</p>

<pre><code class="vim Intero settings">" Prefer starting Intero manually (faster startup times)
let g:intero_start_immediately = 0
" Use ALE (works even when not using Intero)
let g:intero_use_neomake = 0

augroup interoMaps
  au!

  au FileType haskell nnoremap &lt;silent&gt; &lt;leader&gt;io :InteroOpen&lt;CR&gt;
  au FileType haskell nnoremap &lt;silent&gt; &lt;leader&gt;iov :InteroOpen&lt;CR&gt;&lt;C-W&gt;H
  au FileType haskell nnoremap &lt;silent&gt; &lt;leader&gt;ih :InteroHide&lt;CR&gt;
  au FileType haskell nnoremap &lt;silent&gt; &lt;leader&gt;is :InteroStart&lt;CR&gt;
  au FileType haskell nnoremap &lt;silent&gt; &lt;leader&gt;ik :InteroKill&lt;CR&gt;

  au FileType haskell nnoremap &lt;silent&gt; &lt;leader&gt;wr :w \| :InteroReload&lt;CR&gt;
  au FileType haskell nnoremap &lt;silent&gt; &lt;leader&gt;il :InteroLoadCurrentModule&lt;CR&gt;
  au FileType haskell nnoremap &lt;silent&gt; &lt;leader&gt;if :InteroLoadCurrentFile&lt;CR&gt;

  au FileType haskell map &lt;leader&gt;t &lt;Plug&gt;InteroGenericType
  au FileType haskell map &lt;leader&gt;T &lt;Plug&gt;InteroType
  au FileType haskell nnoremap &lt;silent&gt; &lt;leader&gt;it :InteroTypeInsert&lt;CR&gt;

  au FileType haskell nnoremap &lt;silent&gt; &lt;leader&gt;jd :InteroGoToDef&lt;CR&gt;
  au FileType haskell nnoremap &lt;silent&gt; &lt;leader&gt;iu :InteroUses&lt;CR&gt;
  au FileType haskell nnoremap &lt;leader&gt;ist :InteroSetTargets&lt;SPACE&gt;
augroup END
</code></pre>

<p>Intero takes a little getting used to, so be sure to read the docs for some
sample workflows.</p>

<h2>Wrap Up</h2>

<p>With these tools, I feel empowered rather than hindered when I sit down to write
some Haskell.</p>

<ul>
<li>It uses Stack whenever possible, so things Just Work.

<ul>
<li>As a consequence, this means all these plugins work with the implicit global
Stack project!</li>
</ul>
</li>
<li>It scales up in power:

<ul>
<li>from simple syntax highlighting to a <strong>REPL in the editor</strong>!</li>
<li>from manual indentation to an indentation sledgehammer</li>
</ul>
</li>
</ul>


<p>- - -

### Jake on the Web
<a class="image-link" href="https://avatars5.githubusercontent.com/u/5544532?v=4&u=4640ad0fd7da51dc2a84c5ae9d11a96677b4d185&s=400"><img class="left" src="https://avatars5.githubusercontent.com/u/5544532?v=4&u=4640ad0fd7da51dc2a84c5ae9d11a96677b4d185&s=400" width="135" height="135"></a>
If you cared enough to read that far, you should consider following me on
[GitHub][g] or paying a visit to [my homepage][h]. If this post was about one of
my open source projects, make sure to star it on GitHub! I love hearing what
people think, so feel free to open an issue or send me an email.
 [g]: https://www.github.com/jez/
 [h]: https://jez.io/
</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Tip: sometimes it&rsquo;s handy for <a href="https://github.com/commercialhaskell/stack/blob/3d29b8c/doc/faq.md#why-doesnt-stack-rebuild-my-project-when-i-specify---ghc-options-on-the-command-line">force a complete recompile</a>.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>If you still aren&rsquo;t convinced, the <a href="https://github.com/neovim/neovim#readme">Neovim logo</a> makes for a much better laptop sticker than Vim&rsquo;s.<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p>While listed under &ldquo;neovimhaskell&rdquo; on GitHub, this plugin works with normal Vim, too.<a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
<li id="fn:4">
<p>Chris Done explains the appeal of solving style issues with tooling for Haskell well. The moral of the story is that hindent version 5 ships with only the most popular style formatter in an effort to arrive at a singular Haskell style: <a href="http://chrisdone.com/posts/hindent-5">http://chrisdone.com/posts/hindent-5</a><a href="#fnref:4" rev="footnote">&#8617;</a></p></li>
<li id="fn:5">
<p>Some people are familiar with Neomake for this task. However, Neomake is much more minimal than ALE. Neomake basically only builds, whereas ALE is more configurable and hackable.<a href="#fnref:5" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Reach for Markdown, not LaTeX]]></title>
    <link href="https://blog.jez.io/2017/02/26/reach-for-markdown-not-latex/"/>
    <updated>2017-02-26T21:26:53-05:00</updated>
    <id>https://blog.jez.io/2017/02/26/reach-for-markdown-not-latex</id>
    <content type="html"><![CDATA[<p>I&rsquo;ve written <a href="/2014/10/06/offline-latex-development/">in the past</a> (<a href="/2015/01/10/offline-latex-development-part-2/">twice</a>) about how to
streamline the writing process when using LaTeX. Since then, I&rsquo;ve found that I
enjoy writing even more when I don&rsquo;t have to reach for LaTeX at all. By reaching
first for Markdown, then for LaTeX when necessary, writing is easier and more
enjoyable.</p>

<!-- more -->


<h2>Writing at the Command Line</h2>

<p>Last year, I <a href="https://jez.io/talks/writing-at-the-command-line/">gave a talk</a> about the merits of writing primarily at
the command line. My main claims were that when writing we want:</p>

<ul>
<li>an open document format (so that our writings are future proof)</li>
<li>to be using open source software (for considerations of privacy and cost)</li>
<li>to optimize for the &ldquo;common case&rdquo;</li>
<li>to be able to write for print and digital (PDFs, web pages, etc.)</li>
</ul>


<p>Markdown solves these constraints nicely:</p>

<ul>
<li>It&rsquo;s a plain text format&mdash;plain text has been around for decades and will
be for decades more.</li>
<li>Given a plain text format, we can bring our own text editor.</li>
<li>Plenty of open source programs manipulate Markdown.</li>
<li>When we need advanced features, we can mix LaTeX into our Markdown documents.</li>
</ul>


<p>For those unfamiliar with Markdown, it&rsquo;s super quick to pick up. If you only
look at one guide, see this one:</p>

<ul>
<li><a href="http://commonmark.org/help/">CommonMark</a></li>
</ul>


<p>If you want to start comparing features available in certain implementations of
Markdown:</p>

<ul>
<li><a href="https://guides.github.com/features/mastering-markdown/">GitHub Flavored Markdown</a></li>
<li><a href="https://daringfireball.net/projects/markdown/">Markdown.pl</a></li>
<li><a href="http://pandoc.org/MANUAL.html#pandocs-markdown">Pandoc Markdown</a></li>
</ul>


<p>For more on why you should want to be writing at the command line, you can
<a href="https://jez.io/talks/writing-at-the-command-line/">check out the talk slides</a>.</p>

<h2>Pandoc Starter</h2>

<p>The central tool I spoke about in <em>Writing at the Command Line</em> is <a href="https://pandoc.org/">Pandoc</a>.
Pandoc is an amazingly simple command line program that takes in Markdown files
and spits out really anything you can think of.</p>

<p>To make using Pandoc even easier than it already is, I put together a
<a href="https://github.com/jez/pandoc-starter">collection of starter templates</a>. They&rsquo;re all available <a href="https://github.com/jez/pandoc-starter">on
Github</a> if you&rsquo;d prefer to dive right in.</p>

<p>There are currently six different templates, specialized for the kind of
document you&rsquo;d like to create. Each has a <code>README</code> for installation and usage
instructions, as well as a <code>Makefile</code> for invoking <code>pandoc</code> correctly.</p>

<p>All the templates generate PDFs from Markdown by way of LaTeX. In addition to
Pandoc, you&rsquo;ll also need LaTeX installed locally.</p>

<h3><a href="https://github.com/jez/pandoc-starter/tree/master/article"><code>article</code></a></h3>

<p>This template uses the standard LaTeX <code>article</code> document class. It&rsquo;s a
no frills, no nonsense choice.</p>

<p><a href="https://github.com/jez/pandoc-starter/blob/master/article/src/sample.pdf"><img src="/images/pandoc-starter-article.png" alt="article template" /></a></p>

<h3><a href="https://github.com/jez/pandoc-starter/tree/master/tufte-handout"><code>tufte-handout</code></a></h3>

<p>As an alternative to the <code>article</code> document class, there&rsquo;s also the
<code>tufte-handout</code> document class. It originates from the style Edward Tufte
popularized in his books and articles on visualization and design.</p>

<p>Apart from a different font (it uses Palatino instead of the default Computer
Modern), this template features the ability add side notes to your documents. I
often find myself reaching for this template when I want to disguise the fact
that I&rsquo;m secretly using LaTeX.</p>

<p><a href="https://github.com/jez/pandoc-starter/blob/master/tufte-handout/src/sample.pdf"><img src="/images/pandoc-starter-tufte-handout.png" alt="tufte-handout template" /></a></p>

<h3><a href="https://github.com/jez/pandoc-starter/tree/master/tufte-handout"><code>homework</code></a></h3>

<p>A second alternative to the <code>article</code> document class is the <code>homework</code> document
class. It works nicely for homework assignments and problem sets. The class
itself has a number of handy features, like:</p>

<ul>
<li>the option to put your name on every page, or only on the first page</li>
<li>an option to use wide or narrow margins</li>
<li>most of the AMS Math packages you&rsquo;d include in the process of typesetting a
math assignment</li>
<li>a convenient environment for typesetting induction proofs</li>
</ul>


<p>For more features and usage information, check out <a href="/2015/01/10/the-latex-homework-document-class/">this blog post</a> or
<a href="https://github.com/jez/latex-homework-class">the source</a> on GitHub.</p>

<p><a href="https://github.com/jez/pandoc-starter/blob/master/homework/src/sample.pdf"><img src="/images/pandoc-starter-homework.png" alt="homework template" /></a></p>

<h3><a href="https://github.com/jez/pandoc-starter/tree/master/beamer"><code>beamer</code></a></h3>

<p>LaTeX provides the <code>beamer</code> document class for creating slides; this template
makes it even easier to use:</p>

<ul>
<li>Make a new slide with a &ldquo;<code>##</code>&rdquo; header</li>
<li>Make a section divider with a &ldquo;<code>#</code>&rdquo; header</li>
<li>Mix lists, links, code, and other Markdown features you&rsquo;re familiar with to
create the content for a slide.</li>
</ul>


<p>So basically, just write the outline for your talk, and Pandoc takes care of
making the slides&mdash;it doesn&rsquo;t get much simpler.</p>

<p><a href="https://github.com/jez/pandoc-starter/blob/master/beamer/src/sample.pdf"><img src="/images/pandoc-starter-beamer.png" alt="beamer template" /></a></p>

<h3><a href="https://github.com/jez/pandoc-starter/tree/master/beamer-solarized"><code>beamer-solarized</code></a></h3>

<p>The default beamer styles are pretty boring. To add a bit of flair and
personality to my slide decks, I made a Solarized theme for beamer.</p>

<p>In addition to the screenshot below, the <a href="https://jez.io/talks/writing-at-the-command-line/">Writing at the Command
Line</a> slides I linked to earlier also use this theme, if you want
to see a less contrived example.</p>

<p><a href="https://github.com/jez/pandoc-starter/blob/master/beamer-solarized/src/sample.pdf"><img src="/images/pandoc-starter-beamer-solarized.png" alt="beamer solarized template" /></a></p>

<h3><a href="https://github.com/jez/pandoc-starter/tree/master/book-writeup"><code>book-writeup</code></a></h3>

<p>Finally, sometimes a simple article or slide deck doesn&rsquo;t cut it. Usually this
means I&rsquo;d like to group the writing into chapters. This template makes writing a
chapter as easy as using a &ldquo;<code>#</code>&rdquo; Markdown header.</p>

<p><a href="https://github.com/jez/pandoc-starter/blob/master/book-writeup/src/sample.pdf"><img src="/images/pandoc-starter-book-writeup.png" alt="book writeup template" /></a></p>

<h2>Writing Plugins for Vim</h2>

<p>If you happen to use Vim, I&rsquo;d highly recommend installing <a href="https://github.com/junegunn/goyo.vim">goyo.vim</a> for
writing. It removes all the visual frills Vim includes to make writing code
easier so you can focus on your writing without distractions.</p>

<p>I also really enjoy <a href="https://github.com/vim-pandoc/vim-pandoc">vim-pandoc</a> and <a href="https://github.com/vim-pandoc/vim-pandoc-syntax">vim-pandoc-syntax</a>. They&rsquo;re a pair of
complementary plugins for highlighting and working with Pandoc Markdown-flavored
documents. They work so well that I use them for Markdown documents even when
not using Pandoc.</p>

<h2>Reach for Markdown</h2>

<p>Writing should be a pleasant experience. With the right tools, it can be. LaTeX
is powerful but cumbersome to use. With Markdown, we can focus on our writing,
and worry about the presentation later. Pandoc can take care of the presentation
for us, so the <a href="https://github.com/jez/pandoc-starter">only thing left to do is start</a>.</p>

<p>- - -

### Jake on the Web
<a class="image-link" href="https://avatars5.githubusercontent.com/u/5544532?v=4&u=4640ad0fd7da51dc2a84c5ae9d11a96677b4d185&s=400"><img class="left" src="https://avatars5.githubusercontent.com/u/5544532?v=4&u=4640ad0fd7da51dc2a84c5ae9d11a96677b4d185&s=400" width="135" height="135"></a>
If you cared enough to read that far, you should consider following me on
[GitHub][g] or paying a visit to [my homepage][h]. If this post was about one of
my open source projects, make sure to star it on GitHub! I love hearing what
people think, so feel free to open an issue or send me an email.
 [g]: https://www.github.com/jez/
 [h]: https://jez.io/
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Troubleshooting Haskell Stack Setup on OS X]]></title>
    <link href="https://blog.jez.io/2016/08/03/troubleshooting-haskell-stack-setup-on-os-x/"/>
    <updated>2016-08-03T00:04:08-04:00</updated>
    <id>https://blog.jez.io/2016/08/03/troubleshooting-haskell-stack-setup-on-os-x</id>
    <content type="html"><![CDATA[<p>Stephen Diehl&rsquo;s article <a href="http://www.stephendiehl.com/posts/vim_2016.html">Vim and Haskell in 2016</a> does a great
job of outlining the quickest way to get a quality Haskell development
experience. I ran into a simple issue when I followed it due to a bit of an
idiosyncrasy on OS X El Capitan. I also document a few of the extra steps I took
which aren&rsquo;t mentioned explicitly in his original article.</p>

<!-- more -->


<p>This post wouldn&rsquo;t actually be necessary if it weren&rsquo;t for one thing: <a href="https://support.apple.com/en-us/HT204899">System
Integrity Protection</a> in OS X El Capitan, also known as &ldquo;rootless&rdquo;
mode. It affects Haskell&rsquo;s build and install step in a subtle (but solved) way,
and the rest of the article will cover what to watch out for when installing on
OS X.</p>

<p>If you don&rsquo;t follow these instructions and you&rsquo;re on OS X El Capitan, you&rsquo;ll
likely run into an issue that looks like <code>/usr/bin/ar: permission denied</code>. The
Stack installation instructions call this out specifically:</p>

<blockquote><p>If you are on OS X 10.11 (&ldquo;El Capitan&rdquo;) or later, GHC 7.8.4 is incompatible
with System Integrity Protection (a.k.a. &ldquo;rootless&rdquo;). GHC 7.10.2 includes a
fix, so this only affects users of GHC 7.8.4.</p></blockquote>

<p>At the risk of spoiling the surprise, we&rsquo;re going to set up Stack while taking
care to make sure that we get GHC >= 7.10. So let&rsquo;s do just that!</p>

<h2>Environment Prep (optional)</h2>

<p>Note that this step is optional and has nothing to do with OS X; I just wanted
to point it out quickly.</p>

<p>Under <a href="http://www.stephendiehl.com/posts/vim_2016.html#dev-environment">Dev Environment</a> on <a href="http://www.stephendiehl.com/posts/vim_2016.html">Vim and Haskell in
2016</a>, Stephen Diehl writes:</p>

<blockquote><p>Times have changed quite a bit, and the new preferred way of installing GHC in
2016 is to forgo using the system package manager for installing ghc and use
Stack to manage the path to the compiler executable and sandboxes.</p></blockquote>

<p>Stack stores it&rsquo;s metadata in the <code>~/.stack</code> folder by default. If you&rsquo;re not a
huge fan of things cluttering up your home folder, set the <code>STACK_ROOT</code> variable
in you bashrc or zshrc:</p>

<pre><code class="bash Set STACK_ROOT to avoid clutter">export XDG_DATA_HOME="$HOME/.local/share"

# Have Haskell Stack use XDG Base Directory spec
export STACK_ROOT="$XDG_DATA_HOME/stack"
</code></pre>

<p>Of course, the choice of location is up to you. In particular I&rsquo;ve chosen to
adhere to the <a href="https://wiki.archlinux.org/index.php/XDG_Base_Directory_support">XDG Base Directory specification</a> here, which you may want
to take a peek at if you&rsquo;re unfamiliar. That&rsquo;s why you see references to
<code>XDG_DATA_HOME</code>.</p>

<p>Make sure you restart your terminal to pick up the new variables before
continuing.</p>

<h2>Install Stack from Homebrew</h2>

<p>If you&rsquo;re like me, you&rsquo;ll want to take a second to purge anything
Haskell-related from previous botched setup attempts:</p>

<pre><code class="bash Wipe the slate clean"># If you had GHC installed
$ brew uninstall ghc

# If you tried and failed at installing Stack already
$ brew uninstall haskell-stack
$ rm -r ~/.stack
# If you happened to also set STACK_ROOT
$ rm -r $STACK_ROOT
</code></pre>

<p>With that out of the way, we can actually get our hands on Stack. For OS X,
we&rsquo;ll install through Homebrew:</p>

<pre><code class="console Install Stack">$ brew install haskell-stack
</code></pre>

<h2>Configure Stack, avoiding &ldquo;rootless&rdquo; issues</h2>

<p>Here&rsquo;s the trick. We need to run <code>stack setup</code> for the first time to let Stack
configure itself. But remember: we want to make sure that Stack doesn&rsquo;t set
itself up with version 7.8.4 of GHC. We can get around this by specifying an
explicit resolver to the <code>stack</code> command (you can find more information on
&ldquo;resolvers&rdquo; elsewhere):</p>

<pre><code class="bash Side-step rootless issue in setup"># Change the resolver to the most up-to-date one. This is a hack to ensure that
# get GHC version &gt; 7.8, because there's an issue with El Capitan's rootless
# mode.
stack --resolver=lts-6.10 setup
</code></pre>

<p>You&rsquo;ll notice we use the <code>--resolver=...</code> flag to force Stack to use a specific
resolver. This post will be out of date as soon as it&rsquo;s written, so check
<a href="https://www.stackage.org/snapshots">Stackage</a> to find the latest LTS snapshot.</p>

<h2>Return to Vim and Haskell in 2016</h2>

<p>That&rsquo;s it for the environment setup! Now you&rsquo;ll want to turn your attention to
configuring Vim.</p>

<p>The steps to set up Vim are platform independent, so now that we&rsquo;ve set up Stack
correctly, you can head over to <a href="http://www.stephendiehl.com/posts/vim_2016.html">Vim and Haskell in 2016</a> to
finish things out.</p>

<p>- - -

### Jake on the Web
<a class="image-link" href="https://avatars5.githubusercontent.com/u/5544532?v=4&u=4640ad0fd7da51dc2a84c5ae9d11a96677b4d185&s=400"><img class="left" src="https://avatars5.githubusercontent.com/u/5544532?v=4&u=4640ad0fd7da51dc2a84c5ae9d11a96677b4d185&s=400" width="135" height="135"></a>
If you cared enough to read that far, you should consider following me on
[GitHub][g] or paying a visit to [my homepage][h]. If this post was about one of
my open source projects, make sure to star it on GitHub! I love hearing what
people think, so feel free to open an issue or send me an email.
 [g]: https://www.github.com/jez/
 [h]: https://jez.io/
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SML Dev Setup]]></title>
    <link href="https://blog.jez.io/2016/03/09/sml-dev-setup/"/>
    <updated>2016-03-09T21:06:15-05:00</updated>
    <id>https://blog.jez.io/2016/03/09/sml-dev-setup</id>
    <content type="html"><![CDATA[<p>When it comes right down to it, SML is a pretty great language. It&rsquo;s clear that
extensive thought has gone into its design and implementation. I quite enjoy
programming in SML, due in no small part to my collection of workflow hacks that
make editing and developing with SML responsive and interactive.</p>

<!-- more -->


<p>We&rsquo;re going to be walking through a couple easy steps you can take to make
developing SML feel more fluid, both in and out of your editor. I have a slight
preference for Vim on OS X, but many of these steps are platform agnostic.</p>

<h2>Installing SML Locally</h2>

<p>While developing SML in a remote environment like the shared Andrew Unix
machines makes it easy to dive right in, working with SML for prolonged periods
of time is best done locally.</p>

<p>On OS X and Ubuntu, the two most popular SML implementations are already
packaged. Take the time to install a version of SML right now. At CMU, we use
<a href="http://smlnj.org/">SML/NJ</a>, which is convenient because it has a REPL that lets you play
around with SML interactively. If you&rsquo;d like to play around with compiling and
distributing programs written in SML, you might want to install <a href="http://www.mlton.org/">MLton</a>.</p>

<pre><code class="bash Install SML from your package manager"># SML/NJ on OS X
brew install smlnj
# -- or --
# MLton on OS X
brew install mlton

# SML/NJ on Ubuntu
sudo apt-get install smlnj
# -- or --
# MLton on Ubuntu
sudo apt-get install mlton
</code></pre>

<p>Feel free to install both if you&rsquo;d like; they&rsquo;ll play nicely with each other and
each offers advantages over the other.</p>

<p>Note for OS X users: if you&rsquo;ve never used <a href="http://brew.sh">Homebrew</a> before, you&rsquo;ll need
to <a href="http://brew.sh">install it first</a>.</p>

<h2>Getting Comfortable with SML/NJ</h2>

<p>The rest of these steps should apply regardless of whether you&rsquo;re working on SML
locally or remotely.</p>

<p>One thing that I&rsquo;ve seen far too many times from course documentation is that
they tell students to run their code like this:</p>

<ol>
<li>Run <code>sml</code></li>
<li>Type <code>use "foo.sml";</code> or <code>CM.make "sources.cm";</code> at the REPL</li>
</ol>


<p>Don&rsquo;t get me wrong; this works, but there&rsquo;s a better way. Being responsible
CLI-citizens, we should always be looking for ways to tab-complete. Let&rsquo;s do
this by changing our workflow:</p>

<ol>
<li>Run <code>sml foo.sml</code> or <code>sml -m sources.cm</code></li>
</ol>


<p>Look at that! We&rsquo;ve,</p>

<ul>
<li>dropped a step (having to launch the REPL first), and</li>
<li>introduced tab completion into our workflow (because the shell has filename
completion)</li>
</ul>


<p>It&rsquo;s the little things, but they add up.</p>

<h2>Enhancing the REPL</h2>

<p>Speaking of the little things, when using the SML REPL, you don&rsquo;t have access to
all the usual command line niceties like command history and access to arrow
keys for editing, let alone Vi-like keybindings. To get started, you&rsquo;ll have to
change how you launch the SML/NJ REPL. In particular, we&rsquo;re going to preface our
commands with <code>rlwrap</code>:</p>

<pre><code class="bash"># instead of this...
$ sml

# use this:
$ rlwrap sml
</code></pre>

<p><code>rlwrap</code> stands for &ldquo;readline wrap.&rdquo; Readline is a library that simply adds to a
REPL program all the features mentioned above:</p>

<ul>
<li>Command history tracking</li>
<li>Line editing with arrow keys</li>
<li>Configurability through the <code>~/.inputrc</code> file

<ul>
<li>We can use this to get fancy features like Vi keybindings</li>
</ul>
</li>
</ul>


<p>For more information, see <a href="https://github.com/jez/dotfiles/blob/ed8e531eebe43a8aef05fc4cb768157d03408cea/inputrc#L12-L14">these lines</a> of my inputrc, a small part of
my <a href="https://github.com/jez/dotfiles">dotfiles repo</a> on GitHub.</p>

<h2>Setting Up Vim</h2>

<p>Programming is so much more enjoyable when you&rsquo;re not fighting your editor. For
me, this means striving to get the most out of Vim. In this section, I&rsquo;ll
outline all the cool tips and tricks I have for developing SML in Vim.</p>

<p>But first, if you&rsquo;ve never taken a look into how to configure Vim, I suggest you
start out by walking through this quick workshop called <a href="https://github.com/jez/vim-as-an-ide">Vim as an
IDE</a>. It&rsquo;ll teach you where to start when configuring Vim and get
you set up with a bunch of standard plugins that improve on the standard Vim
experience tenfold.</p>

<p>No actually, take a second and <a href="https://github.com/jez/vim-as-an-ide">walk through it</a>. We&rsquo;ll still be
here when you&rsquo;re done, and you&rsquo;ll appreciate Vim more when you&rsquo;re done.</p>

<h3>Syntastic</h3>

<p>From the Syntastic documentation:</p>

<blockquote><p>Syntastic is a syntax checking plugin for Vim that runs files through
external syntax checkers and displays any resulting errors to the user. This
can be done on demand, or automatically as files are saved. If syntax errors
are detected, the user is notified and is happy because they didn&rsquo;t have to
compile their code or execute their script to find them.</p></blockquote>

<p>And the best part? Syntastic ships with a checker for SML by default if you
have SML/NJ installed.</p>

<p>If you didn&rsquo;t just install <a href="https://github.com/scrooloose/syntastic">Syntastic</a> from the Vim as an IDE
walkthrough, you can <a href="https://github.com/scrooloose/syntastic">visit their homepage</a> for installation
instructions. Go ahead and do this now, then try writing this in a file called
<code>test.sml</code>:</p>

<pre><code class="sml test.sml">val foo : string = 42
</code></pre>

<p>You should see an &lsquo;x&rsquo; next to the line and a description of the error from the
type checker. You can imagine how handy this is.</p>

<h3>Extra Syntastic Setup</h3>

<p>Syntastic has their own set of <a href="https://github.com/scrooloose/syntastic#settings">recommended settings</a> that
you can add at your discretion. At the very least, I&rsquo;d suggest adding these
lines to your vimrc:</p>

<pre><code class="vim .vimrc">...

augroup mySyntastic
  " tell syntastic to always stick any detected errors into the location-list
  au FileType sml let g:syntastic_always_populate_loc_list = 1

  " automatically open and/or close the location-list
  au FileType sml let g:syntastic_auto_loc_list = 1
augroup END

" press &lt;Leader&gt;S (i.e., \S) to not automatically check for errors
nnoremap &lt;Leader&gt;S :SyntasticToggleMode&lt;CR&gt;

...
</code></pre>

<p>By default, whenever you save your file, Syntastic will place symbols in Vim&rsquo;s
<em>sign column</em> next to lines with errors. The first two settings above tell
Syntastic to also show a summarized list of errors at the bottom of the screen.
The final setting lets you press <code>&lt;Leader&gt;S</code> (which is usually just <code>\S</code>) to
disable all that. This is useful when you&rsquo;re still unfinished and you know your
SML isn&rsquo;t going to type check. Press it again to re-enable it.</p>

<p>Also, a tip for those who&rsquo;ve never used Vim&rsquo;s location list feature before: you
can close the list with <code>:lclose</code>.</p>

<h3><code>vim-better-sml</code></h3>

<p>The curious at this point might be wondering if Syntastic is smart enough to
figure out when the file you&rsquo;re using requires a CM file to compile and uses it
to show you where the errors are instead. As it turns out: no, <a href="https://github.com/scrooloose/syntastic/pull/1719">that&rsquo;s not a
feature Syntastic wants to include</a> by default. However, the
functionality isn&rsquo;t hard to implement, and there&rsquo;s already a plugin for it!</p>

<p><a href="https://github.com/jez/vim-better-sml">vim-better-sml</a> is one of my Vim plugins. Here&rsquo;s a quick
rundown of its features:</p>

<ul>
<li>As already mentioned, it will detect when your file requires a CM file to
build, and will pass along the information to Syntastic</li>
<li><code>let</code> expressions are indented one level under <code>fun</code> declarations</li>
<li><code>*.sig</code> files are properly detected as SML signature files</li>
<li>Apostrophe characters are treated as keywords characters</li>
<li>The comment string is properly registered for SML files</li>
</ul>


<p>For more information, including how to install it, check out the homepage:
<a href="https://github.com/jez/vim-better-sml">vim-better-sml</a>.</p>

<h2>General Vim Settings</h2>

<p>As a quick addendum, one common complaint people have when editing SML is that
it forces the line to wrap if it extends to 80 characters. Some people don&rsquo;t
like that it does this, and others don&rsquo;t like that it doesn&rsquo;t do it frequently
enough (namely, it only wraps the line if your cursor extends past 80
characters, not the end of the line).</p>

<p>If you don&rsquo;t want Vim to do any of this wrapping, run this:</p>

<pre><code class="vim Disable hard line wrapping">setlocal textwidth=0
</code></pre>

<p>If you&rsquo;d like this change to persist between Vim sessions, add it to
<code>~/.vim/after/ftplugin/sml.vim</code>. These folders and file likely don&rsquo;t exist
yet; you&rsquo;ll have to create them. The <code>after</code> folder in Vim is used to override
settings loaded from plugins. As you might have guessed, files in here are run
after plugin code is.</p>

<p>Conversely, if you&rsquo;d like a little better idea when Vim&rsquo;s going to hard wrap
your line, you can add this line to your vimrc:</p>

<pre><code class="vim Show a color column">set colorcolumn+=0
</code></pre>

<p>Note: this will only work if you&rsquo;re using Vim 7.4 or above. This setting tells
Vim to draw a solid column at the same width as the value of the <code>textwidth</code>
setting.</p>

<h2>TL;DR</h2>

<p>We covered a lot, so here&rsquo;s a quick recap:</p>

<ul>
<li>Install SML locally. It&rsquo;s super easy to do on OS X and Linux (use your package
manager), and means you don&rsquo;t have have a Wi-Fi connection to develop SML.</li>
<li>Invest time into learning Vim. Here&rsquo;s a reference: <a href="https://github.com/jez/vim-as-an-ide">Vim as an
IDE</a>.</li>
<li>Install <a href="https://github.com/scrooloose/syntastic">Syntastic</a>. It tells you what lines your errors are on.</li>
<li>Install <a href="https://github.com/jez/vim-better-sml">vim-better-sml</a>. It includes some features Syntastic
doesn&rsquo;t by default, and includes a couple extras.</li>
<li>Consider using <code>setlocal textwidth=0</code> or <code>set colorcolumn+=0</code> to deal with the
80-character restriction when writing SML files.</li>
</ul>


<p>And as always, you can see even more Vim settings in my <a href="https://github.com/jez/dotfiles">dotfiles
repo</a> on GitHub.</p>

<p>- - -

### Jake on the Web
<a class="image-link" href="https://avatars5.githubusercontent.com/u/5544532?v=4&u=4640ad0fd7da51dc2a84c5ae9d11a96677b4d185&s=400"><img class="left" src="https://avatars5.githubusercontent.com/u/5544532?v=4&u=4640ad0fd7da51dc2a84c5ae9d11a96677b4d185&s=400" width="135" height="135"></a>
If you cared enough to read that far, you should consider following me on
[GitHub][g] or paying a visit to [my homepage][h]. If this post was about one of
my open source projects, make sure to star it on GitHub! I love hearing what
people think, so feel free to open an issue or send me an email.
 [g]: https://www.github.com/jez/
 [h]: https://jez.io/
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Noteworthy Dotfile Hacks]]></title>
    <link href="https://blog.jez.io/2015/03/10/noteworthy-dotfile-hacks/"/>
    <updated>2015-03-10T01:22:33-04:00</updated>
    <id>https://blog.jez.io/2015/03/10/noteworthy-dotfile-hacks</id>
    <content type="html"><![CDATA[<p>I have hundreds of files and folders in my dotfiles repo, and nearly 1000
commits&mdash;there are quite a few hidden gems buried in there that generally don&rsquo;t
get to see the light of day. Rather than wander aimlessly through them, let me
give you the guided tour.</p>

<!-- more -->


<p>I often tell people &ldquo;oh, and you can also go check out my dotfiles repository
for more cool configurations&rdquo; when I&rsquo;m giving out dotfiles advice. If someone
gave me this advice, I know I wouldn&rsquo;t follow up, even if I had the utmost awe
for the recommender. Drudging through config files isn&rsquo;t all that fun, even
though they can do fun things. Why not get rid of the drudgery?</p>

<p>This post is designed to bring the coolest parts of my dotfiles to the top. It&rsquo;s
organized by topic, so feel free to skip around.</p>

<p><strong>Note</strong>: throughout this post, I&rsquo;ll be linking to my dotfiles <em>at a specific
commit</em> on GitHub. While this solves the problem of line-level links breaking on
updates, it means that you&rsquo;ll almost certainly be looking at out-dated code.
Make sure to check out the corresponding file on the <code>master</code> branch for the
most up-to-date version.</p>

<p>Also, I <a href="/2015/03/09/getting-started-with-rcm/">just wrote</a> about one of my biggest dotfile hacks: using rcm
to keep my dotfiles in sync across machines. Be sure to give it a read if you&rsquo;re
running into that problem.</p>

<h2><code>tmux</code></h2>

<p>I have a lot of cool stuff going on in my <code>.tmux.conf</code></p>

<ul>
<li>I <a href="https://github.com/jez/dotfiles/blob/0ca7dfb042e8d0e6790e7142487812517b5a4209/tmux.conf#L1-L4">bind the prefix key to <code>C-f</code></a>, something which I haven&rsquo;t seen
many people do.  I&rsquo;ve never had a problem with it conflicting with commonly
used shortcuts, and it&rsquo;s incredibly easy to press (compared with the common
options of <code>C-a</code> and <code>C-b</code>)</li>
<li>I integrate with two Vim plugins:

<ul>
<li><a href="https://github.com/jez/dotfiles/blob/0ca7dfb042e8d0e6790e7142487812517b5a4209/tmux.conf#L18-L27">vim-tmux-navigator</a>, which lets you jump between vim
splits and tmux splits as if they were the same thing</li>
<li><a href="https://github.com/jez/dotfiles/blob/0ca7dfb042e8d0e6790e7142487812517b5a4209/tmux.conf#L48-L49">tmuxline</a>, which makes my tmux status bar look just like Vim with
vim-airline (it even pulls down the colors from your Vim configuration!).</li>
</ul>
</li>
</ul>


<h2><code>dircolors</code></h2>

<p>I use the GNU <code>dircolors</code> command to change the colors output by the <code>ls</code>
program. After running <code>brew install coreutils</code> on OS X, I&rsquo;m able to see the
colors thanks to <a href="https://github.com/jez/dotfiles/blob/0ca7dfb042e8d0e6790e7142487812517b5a4209/dircolors">this file</a> and <a href="https://github.com/jez/dotfiles/blob/0ca7dfb042e8d0e6790e7142487812517b5a4209/host-Jacobs-MacBook-Air/util/host.sh#L19-L21">this snippet</a> in my zshrc.</p>

<p><a class="image-link" href="href="https://raw.githubusercontent.com/huyz/dircolors-solarized/master/img/screen-dircolors-in-iTerm2-solarized_dark.png">https://raw.githubusercontent.com/huyz/dircolors-solarized/master/img/screen-dircolors-in-iTerm2-solarized_dark.png</a>&#8221;><img class="<a" src="href="https://raw.githubusercontent.com/huyz/dircolors-solarized/master/img/screen-dircolors-in-iTerm2-solarized_dark.png">https://raw.githubusercontent.com/huyz/dircolors-solarized/master/img/screen-dircolors-in-iTerm2-solarized_dark.png</a>&#8221;></a></p>

<p>(image from the <a href="https://github.com/seebi/dircolors-solarized">dircolors-solarized</a> repository on GitHub)</p>

<h2><code>gitconfig</code></h2>

<p>I talked about this <a href="/2015/01/16/mastering-git-log-for-collaboration/">in a previous post</a>, but I have some <a href="https://github.com/jez/dotfiles/blob/eba0202443de6bcc171dbe6bc133fa9fe02357f7/host-Jacobs-MacBook-Air/gitconfig#L20-L24">special
settings</a> in my global gitconfig for adding colored decoration to git
log commands. Here&rsquo;s a screenshot from that post:</p>

<p><a class="image-link" href="/images/glla-tartanhacks.png"><img src="/images/glla-tartanhacks.png"></a></p>

<h2><code>aklog cs.cmu.edu</code></h2>

<p>For my friends at CMU, I have <code>aklog cs.cmu.edu</code> in <a href="https://github.com/jez/dotfiles/blob/eba0202443de6bcc171dbe6bc133fa9fe02357f7/host-andrew/util/host.zshenv#L1">my ~/.zshenv</a>,
which gets run even when you log in interactively (like what happens when you
<code>scp</code> something), so that I can copy files from my local machine to the SCS AFS
space, which is useful for doing things like making handins. Note that the file
linked to above is a host-specific file that only &ldquo;exists&rdquo; for me on Andrew
machines. You can read more about my setup <a href="/2015/03/09/getting-started-with-rcm/">in my
previous post</a>.</p>

<h2>zsh-syntax-highlighting</h2>

<p>I use a <a href="https://github.com/jez/dotfiles/blob/eba0202443de6bcc171dbe6bc133fa9fe02357f7/util/misc.zsh#L79-L80">zsh plugin</a> to syntax highlight my commands as I type them
on the command line, similar to how the fish shell does it. It does various
things, like coloring the command red or green based on whether it exists,
underlines filenames that exist, highlights filenames that might be misspelled
in yellow, highlights built-ins like <code>if</code> and <code>for</code> in orange, etc.</p>

<p>Here are some examples from my setup:</p>

<p><a class="image-link" href="/images/zsh-syntax-highlighting-for-loop.png"><img src="/images/zsh-syntax-highlighting-for-loop.png"></a></p>

<p><a class="image-link" href="/images/zsh-syntax-highlighting.png"><img src="/images/zsh-syntax-highlighting.png"></a></p>

<h2>Automatic Dotfile Updates</h2>

<p>I wrote a pretty robust script that reminds me to update my dotfiles and my
system regularly. All it does is remind me to check for system updates once
every 24 hours, but it works so well that I had updated my system <code>bash</code> version
before I even read about Shell Shock!</p>

<p>The relevant links are <a href="https://github.com/jez/dotfiles/blob/eba0202443de6bcc171dbe6bc133fa9fe02357f7/util/auto-update.sh">here</a> for the core script that I <a href="https://github.com/jez/dotfiles/blob/eba0202443de6bcc171dbe6bc133fa9fe02357f7/zshrc#L44-L45">source in
my zshrc</a>, and then the following host specific links:</p>

<ul>
<li><a href="https://github.com/jez/dotfiles/blob/eba0202443de6bcc171dbe6bc133fa9fe02357f7/host-Jacobs-MacBook-Air/util/host.sh#L69-L86">here</a> for my MacBook</li>
<li><a href="https://github.com/jez/dotfiles/blob/eba0202443de6bcc171dbe6bc133fa9fe02357f7/host-ghost.zimmerman.io/util/host.sh#L24-L31">here</a> for my Ubuntu VPS</li>
</ul>


<h2>Shell aliases</h2>

<p>I&rsquo;d like to think that my whole <a href="https://github.com/jez/dotfiles/blob/eba0202443de6bcc171dbe6bc133fa9fe02357f7/util/aliases.sh"><code>aliases.sh</code></a> file is golden, but if
you&rsquo;re looking for some specific things I like about it, check out my <a href="https://github.com/jez/dotfiles/blob/eba0202443de6bcc171dbe6bc133fa9fe02357f7/util/aliases.sh#L75-L86"><code>git log</code></a>
aliases, which I wrote about <a href="/2015/01/16/mastering-git-log-for-collaboration/">here</a>, and my <a href="https://github.com/jez/dotfiles/blob/eba0202443de6bcc171dbe6bc133fa9fe02357f7/util/aliases.sh#L44-L45"><code>chromemem</code></a> alias, which I wrote about <a href="/2014/12/29/google-chrome-a-memory-hog/">here</a>.</p>

<h2>Ruby Virtualenvs</h2>

<p>I wrote about how I use <a href="/2014/12/22/ruby-virtualenvs/">Python Virtualenvs to sandbox Ruby
gems</a>, a post in which I dropped some snippets that you can
use to configure virtualenvwrapper to work with Ruby projects. I actually went
ahead and <a href="https://github.com/jez/dotfiles/tree/eba0202443de6bcc171dbe6bc133fa9fe02357f7/host-Jacobs-MacBook-Air/virtualenvs">fed those files right into rcm</a>, so they&rsquo;ll always be available if I
ever get a new laptop.</p>

<h2><code>ssh</code></h2>

<p>My hostname on every machine I ssh to for school is <code>jezimmer</code>, but there are
countless servers I can ssh into (7 for <code>unix.andrew.cmu.edu</code>, 99+ for
<code>ghc*.ghc.andrew.cmu.edu</code>, 10 for 15-213, the list goes on). <a href="https://github.com/jez/dotfiles/blob/eba0202443de6bcc171dbe6bc133fa9fe02357f7/host-Jacobs-MacBook-Air/ssh/config#L7-L19">These
lines</a> enable me to ssh to any of those machines with just a
hostname, and the username is assumed to be <code>jezimmer</code>.</p>

<h2>iTerm2</h2>

<p>There&rsquo;s not much to show for this one, but in Preferences > General of iTerm2,
you can opt to load your iTerm2 preferences from a specific location. I&rsquo;ve set
this to <code>/Users/jake/.dotfiles</code>, which means that my iTerm2 settings are always
written to my <code>.dotfiles/</code> directory. If I ever make changes to iTerm2, they get
propagated as changes that Git picks up on and which I subsequently check into
Git history.</p>

<h2>Vim</h2>

<p>I&rsquo;m in love with my Vim setup. If you&rsquo;re looking for help getting started
configuring Vim, you should checkout the <a href="https://github.com/jez/vim-as-an-ide">Vim plugins workshop I put
together</a>, which gets you started with a &ldquo;fully-configured&rdquo; Vim
setup. Once you think you&rsquo;ve &ldquo;mastered&rdquo; that and you&rsquo;re ready for more, here are
a list of things I&rsquo;m proud of in my <code>.vimrc</code>:</p>

<ul>
<li><a href="https://github.com/jez/dotfiles/blob/eba0202443de6bcc171dbe6bc133fa9fe02357f7/vimrc#L65-L67"><code>set breakindent</code></a> A feature new in Vim 7.4, this allows you to
align wrapped text at the same indentation level as the preceding text.</li>
<li><a href="https://github.com/jez/dotfiles/blob/eba0202443de6bcc171dbe6bc133fa9fe02357f7/vimrc#L100-L106">these mappings</a>, which let me move around (move up and down in
particular) in long lines just as if they were short.</li>
<li><a href="https://github.com/jez/dotfiles/blob/eba0202443de6bcc171dbe6bc133fa9fe02357f7/vimrc#L90-L91">this mapping</a>, which lets me open Vim help pages in new tabs</li>
</ul>


<h2>Other</h2>

<p>I&rsquo;ve only highlighted a fraction of my configuration files, but I think I&rsquo;ve
managed to capture a good portion of them. If you thought that one of these
snippets was useful, are having trouble getting something to work, or have
something interesting to share, leave a comment below!</p>

<p>- - -

### Jake on the Web
<a class="image-link" href="https://avatars5.githubusercontent.com/u/5544532?v=4&u=4640ad0fd7da51dc2a84c5ae9d11a96677b4d185&s=400"><img class="left" src="https://avatars5.githubusercontent.com/u/5544532?v=4&u=4640ad0fd7da51dc2a84c5ae9d11a96677b4d185&s=400" width="135" height="135"></a>
If you cared enough to read that far, you should consider following me on
[GitHub][g] or paying a visit to [my homepage][h]. If this post was about one of
my open source projects, make sure to star it on GitHub! I love hearing what
people think, so feel free to open an issue or send me an email.
 [g]: https://www.github.com/jez/
 [h]: https://jez.io/
</p>
]]></content>
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: programming | Bits, Bytes, and Words]]></title>
  <link href="https://blog.jez.io/categories/programming/atom.xml" rel="self"/>
  <link href="https://blog.jez.io/"/>
  <updated>2017-09-25T05:26:58-04:00</updated>
  <id>https://blog.jez.io/</id>
  <author>
    <name><![CDATA[Jake Zimmerman]]></name>
    <email><![CDATA[jake@zimmerman.io]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Testing, Types, & Correctness]]></title>
    <link href="https://blog.jez.io/testing-types/"/>
    <updated>2017-09-10T19:50:36-04:00</updated>
    <id>https://blog.jez.io/testing-types</id>
    <content type="html"><![CDATA[<p>Understanding correctness of code really comes down to <em>proving</em> that
the code does the right thing. What tools do we have as programmers for
proving the correctness of our code?</p>

<!-- more -->


<ol>
<li><strong>Unit tests</strong> prove that the code is correct for specific inputs.</li>
<li><strong>Type systems</strong> prove the absence of (certain kinds of)
incorrectness.</li>
<li><strong>Theorem provers</strong> prove sophisticated claims about our code for
us.</li>
<li><strong>Program authors</strong> can prove the correctness of their code (i.e.,
with a traditional pen-and-paper proof).</li>
</ol>


<p>The first three are exciting because they involve a computer doing most
of the work for us! That said, none of the first three are as
universally applicable as the last: doing the proof ourself.
Unfortunately, it&rsquo;s also usually the most toilsome.</p>

<p>Note the double negation in (2). Type systems themselves don&rsquo;t prove
correctness, they prove that there aren&rsquo;t certain kinds of
incorrectness, namely: type errors. Meanwhile, unit tests are rarely (if
ever) exhaustive. This is why testing and type systems are
complementary&mdash;one is not a substitute for the other.</p>

<p>It&rsquo;s important to both have strong testing practices and languages with
disciplined type systems. The hardest part of writing quality software
is ensuring that it runs without bugs. The more tools we have in our
arsenal to combat incorrectness, the easier it is to write code for the
long term.</p>

<!-- vim:tw=72
-->

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[If, Else, & Purity]]></title>
    <link href="https://blog.jez.io/if-else-purity/"/>
    <updated>2017-09-01T01:38:43-04:00</updated>
    <id>https://blog.jez.io/if-else-purity</id>
    <content type="html"><![CDATA[<p>I prefer to let the language I&rsquo;m using think on my behalf as much as
possible. Ideally, the language is rich enough that the proof of
correctness is inherent in the code I&rsquo;ve written. Even when I use
looser languages, these principled languages inform the structure of my
code. To make this a bit more let&rsquo;s turn our focus to <code>if</code>, <code>else</code>, and
purity.</p>

<!-- more -->


<p>A cool way to understand purity is using what&rsquo;s known as a &ldquo;modal
separation.&rdquo; This is a really fancy way to say that we have
<strong>expressions</strong> which are pure and always evaluate to a value, alongside
<strong>commands</strong> which are impure and are executed for their side effects.
If you&rsquo;ve ever used Haskell, you&rsquo;re already familiar with this
notion&mdash;we only need <code>do</code> notation when we need to write impure (or
&ldquo;monadic&rdquo;) code.</p>

<p>In an expression language, every <code>if</code> <em>must</em> have an <code>else</code>; for the
entire <code>if</code> expression to be used as a value, both branches must in turn
evaluate to values. It&rsquo;s only when we move to a language with commands
where it makes sense to allow omitting the <code>else</code> branch. <code>if</code>
expressions are not some abstract concept; chances are you&rsquo;ve
encountered them under the name &ldquo;the ternary operator.&rdquo;</p>

<p>An <code>if</code> <em>statement</em> (as opposed to an <code>if</code> expression) is a command;
it&rsquo;s useful for running side-effectful code. Sometimes, we don&rsquo;t want
one of the branches to have any side effects (for example, because the
state of the world doesn&rsquo;t need to be changed). Languages with commands
allow omitting the <code>else</code>.</p>

<p>What does this mean for us? Since expression languages form the basis
for purity, every pure function can be written where the <code>if</code> is matched
with an <code>else</code>. Put another way, an unmatched <code>if</code> is a likely indicator
that the code I&rsquo;ve written is impure.</p>

<p>This makes me more aware of when I&rsquo;m dealing with impure code. For
example, I might want to factor out as much of the pure code into a
separate helper function. There&rsquo;s a time and a place for impure code.
But since pure code is more composable and easier to test, it&rsquo;s best to
factor the impure code out whenever possible.</p>

<p>In a principled language, there&rsquo;s a distinction between <code>if</code> expressions
and <code>if</code> statements. On the other hand, some language only have one, or
they blur the line between the two. We can draw upon our experiences
with languages that are rigorous about minutia like this to better
inform how we write clean code.</p>

<!-- vim:tw=72
-->

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Joys of the Craft]]></title>
    <link href="https://blog.jez.io/2014/12/13/the-joys-of-the-craft/"/>
    <updated>2014-12-13T20:52:09-05:00</updated>
    <id>https://blog.jez.io/2014/12/13/the-joys-of-the-craft</id>
    <content type="html"><![CDATA[<p>A while ago, I was given the book <em>The Mythical Man-Month</em>, by Frederick P. Brooks, Jr. I finally have some time to sit down and read it, and I&rsquo;m loving it. In the first chapter, this quote on &ldquo;the joys of the craft&rdquo; (i.e., programming) struck me as particularly on point:</p>

<!-- more -->


<blockquote><h3>The Joys of the Craft</h3>

<p>Why is programming fun? What delights may its practitioner expect as his reward?</p>

<p>First is the sheer joy of making things. As the child delights in his mud pie, so the adult enjoys building things, especially things of his own design. I think this delight must be an image of God&rsquo;s delight in making things, a delight shown in the distinctness and newness of each leaf and each snowflake.</p>

<p>Second is the pleasure of making things that are useful to other people. Deep within, we want others to use our work and to find it helpful. In this respect the programming system is not essentially different from the child&rsquo;s first clay pencil holder &ldquo;for Daddy&rsquo;s office.&rdquo;</p>

<p>Third is the fascination of fashioning complex puzzle-like objects of interlocking moving parts and watching them work in subtle cycles, playing out the consequences of principles built in from the beginning. The programmed computer has all the fascination of the pinball machine or the jukebox mechanism, carried to the ultimate.</p>

<p>Fourth is the joy of always learning, which springs from the nonrepearing nature of the task. In one way or another the problem is ever new, and its solver learns something: sometimes practical, sometimes theoretical, and sometimes both.</p>

<p>Finally, there is the delight of working in such a tractable medium. The programmer, like the poet, works only slightly removed from pure thought-stuff. He builds his castles in the air, from air, creating by exertion of the imagination. Few media of creation are so flexible, so easy to polish and rework, so readily capable of realizing grand conceptual structures. (As we shall see later, this very tractability has its own problems.)</p>

<p>Yet the program construct, unlike the poet&rsquo;s words, is real in the sense that it moves and works, producing visible outputs separate from the construct itself. It prints results, draws pictures, produces sounds, moves arms. The magic of myth and legend has come true in our time. One types the correct incantation on a keyboard, and a display screen comes to life, showing things that never were nor could be.</p>

<p>Programming then is fun because it gratifies creative longings built deep within us and delights sensibilities we have in common with all men.</p>

<p>&ndash; &ldquo;The Tar Pit&rdquo;, <em>The Mythical Man-Month</em>, Frederick P. Brooks Jr.</p></blockquote>

<p>Brooks of course follows this up with &ldquo;The Woes of the Craft&rdquo;, which is equally on point. I&rsquo;m only a few pages in, but I already feel like, respectfully, I&rsquo;ve learned more than I did in all of Tech Comm (<a href="https://enr-apps.as.cmu.edu/open/SOC/SOCServlet/courseDetails?COURSE=15221&amp;SEMESTER=F14">15-221</a>). I would absolutely recommend it to anyone considering pursing software engineering!</p>
]]></content>
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: fragment | Bits, Bytes, and Words]]></title>
  <link href="https://blog.jez.io/categories/fragment/atom.xml" rel="self"/>
  <link href="https://blog.jez.io/"/>
  <updated>2018-01-14T03:50:43-05:00</updated>
  <id>https://blog.jez.io/</id>
  <author>
    <name><![CDATA[Jake Zimmerman]]></name>
    <email><![CDATA[jake@zimmerman.io]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ABTs in Haskell]]></title>
    <link href="https://blog.jez.io/abts-in-haskell/"/>
    <updated>2017-11-12T01:31:41-05:00</updated>
    <id>https://blog.jez.io/abts-in-haskell</id>
    <content type="html"><![CDATA[<p>I&rsquo;ve been learning and using Haskell on-and-off for the past couple
of years. One of my early complaints was that I couldn&rsquo;t find a good
library for working with variables and binding that used locally
nameless terms. Recently though, I found <a href="https://github.com/lambdageek/unbound-generics"><code>unbound-generics</code></a>, which
checks all my previously unfilled boxes.</p>

<p>Abstract binding trees (or ABTs) are abstract syntax trees (ASTs)
augmented with the ability to capture the binding structure of a
program. ABTs are one of the first topics we cover in <a href="https://www.cs.cmu.edu/~rwh/courses/ppl/">15-312 Principles
of Programming Languages</a> because variables show up in every
interesting feature of a programming language.</p>

<p>I recently wrote at length about the various strategies for dealing with
<a href="/variables-and-binding/">variables and binding</a> and their implementations. While it&rsquo;s a good
exercise<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> to implement ABTs from scratch, in most cases I&rsquo;d
rather just use a library. In school we used <a href="https://github.com/robsimmons/abbot"><code>abbot</code></a>, which is an ABT
library for Standard ML. For tinkering with Haskell, I recently found
<a href="https://github.com/lambdageek/unbound-generics"><code>unbound-generics</code></a>, which provides a similar API.</p>

<p>I gave it a test drive while learning how to implement type inference
for the simply-typed lambda calculus (STLC) and was rather pleased. The
source code for my STLC inference program is <a href="https://github.com/jez/stlc-infer">on GitHub</a> if
you&rsquo;re looking for an example of <a href="https://github.com/lambdageek/unbound-generics"><code>unbound-generics</code></a> in action.</p>

<p>To pluck a few snippets out, here&rsquo;s the definition of STLC terms:</p>

<pre><code class="haskell">data Term
  = Tvar Tvar
  | Tlam (Bind Tvar Term)
  | Tapp Term Term
  | Tlet Term (Bind Tvar Term)
  | Tz
  | Ts Term
  | Tifz Term Term (Bind Tvar Term)
  | Tbool Bool
  | Tif Term Term Term
  deriving (Show, Generic, Typeable)
</code></pre>

<p><code>Bind</code> is the abstract type for locally nameless terms that bind a
variable. It&rsquo;s cool in Haskell (compared to SML) because the compiler
can automatically derive the locally nameless representation from this
data type definition (with help from the <code>unbound-generics</code> library).</p>

<p>Here&rsquo;s what it looks like in use:</p>

<pre><code class="haskell">-- (This is a snippet from the type inference code)
constraintsWithCon ctx (Tlam bnd) = do
  -- 'out' the ABT to get a fresh variable
  -- (x used to be "locally nameless", but now has a globally unique name)
  (x, e) &lt;- unbind bnd
  -- Generate fresh type variable to put into the context
  t1 &lt;- Cvar &lt;$&gt; fresh (string2name "t1_")
  let ctx' = Map.insert x t1 ctx
  t2 &lt;- constraintsWithCon ctx' e
  return $ Carrow t1 t2
</code></pre>

<p>Apart from <code>out</code> being called <code>unbind</code> and <code>into</code> being called <code>bind</code>,
the API is pretty similar. Also, unlike <code>abbot</code>, which required a
standalone build step to generate SML code, <code>unbound-generics</code> uses the
Haskell&rsquo;s <code>derive Generic</code> to bake the code generation for capture
avoiding substitution and alpha equivalence right into the compiler. All
in all, <code>unbound-generics</code> is really pleasant to use!</p>

<!-- vim:tw=72
-->

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>In fact, it&rsquo;s hw1 for 15-312! If you&rsquo;re curious, check out the <a href="https://www.cs.cmu.edu/~rwh/courses/ppl/hws/assn1.pdf">handout</a>.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Testing, Types, & Correctness]]></title>
    <link href="https://blog.jez.io/testing-types/"/>
    <updated>2017-09-10T19:50:36-04:00</updated>
    <id>https://blog.jez.io/testing-types</id>
    <content type="html"><![CDATA[<p>Understanding correctness of code really comes down to <em>proving</em> that
the code does the right thing. What tools do we have as programmers for
proving the correctness of our code?</p>

<!-- more -->


<ol>
<li><strong>Unit tests</strong> prove that the code is correct for specific inputs.</li>
<li><strong>Type systems</strong> prove the absence of (certain kinds of)
incorrectness.</li>
<li><strong>Theorem provers</strong> prove sophisticated claims about our code for
us.</li>
<li><strong>Program authors</strong> can prove the correctness of their code (i.e.,
with a traditional pen-and-paper proof).</li>
</ol>


<p>The first three are exciting because they involve a computer doing most
of the work for us! That said, none of the first three are as
universally applicable as the last: doing the proof ourself.
Unfortunately, it&rsquo;s also usually the most toilsome.</p>

<p>Note the double negation in (2). Type systems themselves don&rsquo;t prove
correctness, they prove that there aren&rsquo;t certain kinds of
incorrectness, namely: type errors. Meanwhile, unit tests are rarely (if
ever) exhaustive. This is why testing and type systems are
complementary&mdash;one is not a substitute for the other.</p>

<p>It&rsquo;s important to both have strong testing practices and languages with
disciplined type systems. The hardest part of writing quality software
is ensuring that it runs without bugs. The more tools we have in our
arsenal to combat incorrectness, the easier it is to write code for the
long term.</p>

<!-- vim:tw=72
-->

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[If, Else, & Purity]]></title>
    <link href="https://blog.jez.io/if-else-purity/"/>
    <updated>2017-09-01T01:38:43-04:00</updated>
    <id>https://blog.jez.io/if-else-purity</id>
    <content type="html"><![CDATA[<p>I prefer to let the language I&rsquo;m using think on my behalf as much as
possible. Ideally, the language is rich enough that the proof of
correctness is inherent in the code I&rsquo;ve written. Even when I use
looser languages, these principled languages inform the structure of my
code. To make this a bit more let&rsquo;s turn our focus to <code>if</code>, <code>else</code>, and
purity.</p>

<!-- more -->


<p>A cool way to understand purity is using what&rsquo;s known as a &ldquo;modal
separation.&rdquo; This is a really fancy way to say that we have
<strong>expressions</strong> which are pure and always evaluate to a value, alongside
<strong>commands</strong> which are impure and are executed for their side effects.
If you&rsquo;ve ever used Haskell, you&rsquo;re already familiar with this
notion&mdash;we only need <code>do</code> notation when we need to write impure (or
&ldquo;monadic&rdquo;) code.</p>

<p>In an expression language, every <code>if</code> <em>must</em> have an <code>else</code>; for the
entire <code>if</code> expression to be used as a value, both branches must in turn
evaluate to values. It&rsquo;s only when we move to a language with commands
where it makes sense to allow omitting the <code>else</code> branch. <code>if</code>
expressions are not some abstract concept; chances are you&rsquo;ve
encountered them under the name &ldquo;the ternary operator.&rdquo;</p>

<p>An <code>if</code> <em>statement</em> (as opposed to an <code>if</code> expression) is a command;
it&rsquo;s useful for running side-effectful code. Sometimes, we don&rsquo;t want
one of the branches to have any side effects (for example, because the
state of the world doesn&rsquo;t need to be changed). Languages with commands
allow omitting the <code>else</code>.</p>

<p>What does this mean for us? Since expression languages form the basis
for purity, every pure function can be written where the <code>if</code> is matched
with an <code>else</code>. Put another way, an unmatched <code>if</code> is a likely indicator
that the code I&rsquo;ve written is impure.</p>

<p>This makes me more aware of when I&rsquo;m dealing with impure code. For
example, I might want to factor out as much of the pure code into a
separate helper function. There&rsquo;s a time and a place for impure code.
But since pure code is more composable and easier to test, it&rsquo;s best to
factor the impure code out whenever possible.</p>

<p>In a principled language, there&rsquo;s a distinction between <code>if</code> expressions
and <code>if</code> statements. On the other hand, some language only have one, or
they blur the line between the two. We can draw upon our experiences
with languages that are rigorous about minutia like this to better
inform how we write clean code.</p>

<!-- vim:tw=72
-->

]]></content>
  </entry>
  
</feed>

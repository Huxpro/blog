
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->

<head>


<meta charset="utf-8">
<meta http-equiv="cleartype" content="on">

<title>Haskell Development With Neovim - Bits, Bytes, and Words</title>
<meta name="author" content="Jake Zimmerman">




<meta name="description" content="After a year and a half of using Haskell on and off, I've finally settled on a set of high-quality development and editor tools, using Stack and &hellip;">

<meta name="keywords" content="haskell vim ">


<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Twitter Cards -->


<!-- Open Graph -->
<meta property="og:local" content="en_US">
<meta property="og:type" content="article">
<meta property="og:url" content="https://blog.jez.io/2017/07/16/haskell-development-with-neovim">
<meta property="og:title" content="Haskell Development with Neovim">
<meta property="og:description" content="After a year and a half of using Haskell on and off, I've finally settled on a set of high-quality development and editor tools, using Stack and &hellip;">

  <meta property="og:image" content="">

<meta property="og:site_name" content="Bits, Bytes, and Words">

<link rel="canonical" href="https://blog.jez.io/2017/07/16/haskell-development-with-neovim">
<link href="/favicon.png" rel="icon">
<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
<link href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">
<link href="/atom.xml" rel="alternate" title="Bits, Bytes, and Words" type="application/atom+xml">

<script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>
<script>Modernizr || document.write('<script src="/javascripts/vendor/modernizr-2.6.2.custom.min.js"><\/script>') </script>




</head>

<body id="post" >

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
<nav id="dl-menu" class="dl-menuwrapper" role="navigation">
  <button class="dl-trigger">Open Menu</button>
  <ul class="dl-menu">
    <li><a href="/">Home</a></li>
    <li><a href="/posts/">All Posts</a></li>
    <li><a href="/categories/">Posts by Category</a></li>
    <li><a href="https://jez.io">About Jake</a></li><li><a href="https://github.com/jez">GitHub</a></li>
  </ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->




<div id="main" role="main">
  <article class="hentry">
    <header class="header-title">
      <div class="header-title-wrap">
        
          <h1 class="entry-title">Haskell Development with Neovim</h1>
        
        <h2>July 16, 2017</h2>
      </div><!-- /.header-title-wrap -->
    </header>
    <div class="entry-content">
      <p>Configuring an editor for a new language is a double-edged sword: it&rsquo;s intensely
satisfying when done, but takes time away from diving into the language itself!
After using Haskell for a little over a year, I&rsquo;ve settled on a high-quality set
of editor plugins. They&rsquo;re simple, powerful, and all play nicely together.</p>

<!-- more -->


<h2>Requirements</h2>

<p>I use <a href="https://www.haskellstack.org/">Haskell Stack</a> exclusively for managing GHC versions, installing
packages, and building projects. Stack&rsquo;s goal is reproducible builds, which
means that if two different people have the same code and both run <code>stack
build</code>, they both get the same result. Since builds are reproducible, Stack can
cache pretty aggressively to save time in the future<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>. I never have to
invoke <code>ghc</code> or <code>cabal</code> manually; Stack handles everything.</p>

<p>I also use <a href="https://github.com/neovim/neovim">Neovim</a>, rather than normal Vim. Usually my justification
for using it is more philosophical than technical, but with my Haskell setup
it&rsquo;s actually a requirement (we&rsquo;ll see why further on). Neovim is quite stable,
works as a drop-in replacement for Vim, yet brings new features<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>. I love
Neovim, and I&rsquo;ll be writing more about why in a future post.</p>

<!-- TODO(jez): Update with link to Neovim post -->


<h2>Overview</h2>

<p>We&rsquo;re going to move in order of increasing complexity. That said, even the most
&ldquo;complex&rdquo; plugin here is actually quite painless to set up. By the end, we&rsquo;ll
have a complete development experience! Coming up:</p>

<ul>
<li>syntax highlighting &amp; indentation (<a href="https://github.com/neovimhaskell/haskell-vim">haskell-vim</a>)</li>
<li>auto-formatting &amp; style (<a href="https://github.com/commercialhaskell/hindent">hindent</a>, <a href="https://github.com/jaspervdj/stylish-haskell">stylish-haskell</a>)</li>
<li>quickfix and sign column icons (using <a href="https://github.com/w0rp/ale">ale</a>) for:

<ul>
<li>linter style suggestions (hlint)</li>
<li>compiler errors and warnings (ghc-mod)</li>
</ul>
</li>
<li>Type inspection, REPL integration, and <strong>more!</strong> (<a href="https://github.com/parsonsmatt/intero-neovim">intero-neovim</a>)</li>
</ul>


<p>If you just want to browse the final configuration, <a href="https://gist.github.com/jez/ed4dc673385c82243805a19797a37ff6">here&rsquo;s a Gist</a>.</p>

<!-- TODO(jez) Demonstrate everything with an asciicast -->


<h2>Syntax Highlighting &amp; Indentation</h2>

<ul>
<li><strong>Plugin</strong>: <a href="https://github.com/neovimhaskell/haskell-vim">haskell-vim</a><sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup></li>
</ul>


<p>Vim&rsquo;s default Haskell filetype plugin is pretty lack luster. Everything is blue,
except for strings which are colored like comments and keywords which are
colored like constants. Indentation is wonky in some edge cases, and isn&rsquo;t
configurable.</p>

<p>This plugin corrects all that. It&rsquo;s the filetype plugin for Haskell that
<strong>should</strong> ship with Vim.</p>

<p><code>haskell-vim</code> lets me configure certain parts of the indentation, too. These are
my indentation settings. Note that the last setting only works because I&rsquo;ve
merged <a href="https://github.com/neovimhaskell/haskell-vim/pull/98">this PR</a> locally.</p>

<figure class='code'><figcaption><span>neovimhaskell/haskell-vim</span></figcaption><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='vim'><span class='line'><span class="c">" Align 'then' two spaces after 'if'</span>
</span><span class='line'><span class="k">let</span> <span class="nv">g:haskell_indent_if</span> <span class="p">=</span> <span class="m">2</span>
</span><span class='line'><span class="c">" Indent 'where' block two spaces under previous body</span>
</span><span class='line'><span class="k">let</span> <span class="nv">g:haskell_indent_before_where</span> <span class="p">=</span> <span class="m">2</span>
</span><span class='line'><span class="c">" Allow a second case indent style (see haskell-vim README)</span>
</span><span class='line'><span class="k">let</span> <span class="nv">g:haskell_indent_case_alternative</span> <span class="p">=</span> <span class="m">1</span>
</span><span class='line'><span class="c">" Correct bug with aggressive let indentation</span>
</span><span class='line'><span class="k">let</span> <span class="nv">g:haskell_indent_let_no_in</span> <span class="p">=</span> <span class="m">0</span></span></code></pre></td></tr></table></div></figure>


<h2>Auto-formatting and Indentation</h2>

<ul>
<li><strong>Plugin</strong>: <a href="https://github.com/alx741/vim-hindent">vim-hindent</a></li>
<li><strong>Tool</strong>: <code>stack install hindent</code></li>
<li><strong>Tool</strong>: <code>stack install stylish-haskell</code></li>
</ul>


<p>For small projects, I like using my own, personal style. However, for larger
projects it&rsquo;s a burden to ask contributors to learn my personal style. In these
cases, tools come into play.</p>

<p><code>go fmt</code> famously solved this problem for Golang by building the formatting tool
into the compiler. For Haskell, there&rsquo;s <a href="https://github.com/commercialhaskell/hindent">hindent</a><sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>. <code>hindent</code> can be
installed through Stack, and <code>vim-hindent</code> shims it.</p>

<p>But I said I&rsquo;m partial to my own style in personal projects. There&rsquo;s another
Haskell formatter that&rsquo;s much less invasive: <a href="https://github.com/jaspervdj/stylish-haskell">stylish-haskell</a>. It basically
only works with <code>import</code>s, <code>case</code> branches, and record fields, aligning them
vertically.</p>

<p>With these three tools, I can pick the right hammer for the job:</p>

<ul>
<li><strong>Bare hands</strong>: manually control the style myself</li>
<li><strong>Normal hammer</strong>: run <code>stylish-haskell</code> only</li>
<li><strong>Sledgehammer</strong>: run <code>hindent</code> only</li>
<li><strong>Sledgehammer, then band-aid</strong>: run <code>hindent</code>, then <code>stylish-haskell</code></li>
</ul>


<p>Here&rsquo;s the config that gets them to play nicely together:</p>

<figure class='code'><figcaption><span>hindent, vim-hindent, and stylish-haskell</span></figcaption><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='vim'><span class='line'><span class="c">" Indenting on save is too aggressive for me</span>
</span><span class='line'><span class="k">let</span> <span class="nv">g:hindent_on_save</span> <span class="p">=</span> <span class="m">0</span>
</span><span class='line'>
</span><span class='line'><span class="c">" Helper function, called below with mappings</span>
</span><span class='line'><span class="k">function</span><span class="p">!</span> HaskellFormat<span class="p">(</span>which<span class="p">)</span> abort
</span><span class='line'>  <span class="k">if</span> <span class="nv">a:which</span> <span class="p">==</span># <span class="s1">'hindent'</span> <span class="p">||</span> <span class="nv">a:which</span> <span class="p">==</span># <span class="s1">'both'</span>
</span><span class='line'>    <span class="p">:</span>Hindent
</span><span class='line'>  <span class="k">endif</span>
</span><span class='line'>  <span class="k">if</span> <span class="nv">a:which</span> <span class="p">==</span># <span class="s1">'stylish'</span> <span class="p">||</span> <span class="nv">a:which</span> <span class="p">==</span># <span class="s1">'both'</span>
</span><span class='line'>    <span class="k">silent</span><span class="p">!</span> exe <span class="s1">'undojoin'</span>
</span><span class='line'>    <span class="k">silent</span><span class="p">!</span> exe <span class="s1">'keepjumps %!stylish-haskell'</span>
</span><span class='line'>  <span class="k">endif</span>
</span><span class='line'><span class="k">endfunction</span>
</span><span class='line'>
</span><span class='line'><span class="c">" Key bindings</span>
</span><span class='line'>augroup haskellStylish
</span><span class='line'>  <span class="k">au</span><span class="p">!</span>
</span><span class='line'>  <span class="c">" Just hindent</span>
</span><span class='line'>  <span class="k">au</span> <span class="nb">FileType</span> haskell nnoremap <span class="p">&lt;</span>leader<span class="p">&gt;</span><span class="k">hi</span> <span class="p">:</span>Hindent<span class="p">&lt;</span>CR<span class="p">&gt;</span>
</span><span class='line'>  <span class="c">" Just stylish-haskell</span>
</span><span class='line'>  <span class="k">au</span> <span class="nb">FileType</span> haskell nnoremap <span class="p">&lt;</span>leader<span class="p">&gt;</span>hs <span class="p">:</span><span class="k">call</span> HaskellFormat<span class="p">(</span><span class="s1">'stylish'</span><span class="p">)&lt;</span>CR<span class="p">&gt;</span>
</span><span class='line'>  <span class="c">" First hindent, then stylish-haskell</span>
</span><span class='line'>  <span class="k">au</span> <span class="nb">FileType</span> haskell nnoremap <span class="p">&lt;</span>leader<span class="p">&gt;</span>hf <span class="p">:</span><span class="k">call</span> HaskellFormat<span class="p">(</span><span class="s1">'both'</span><span class="p">)&lt;</span>CR<span class="p">&gt;</span>
</span><span class='line'>augroup END</span></code></pre></td></tr></table></div></figure>


<h2>Quickfix &amp; Sign Columns</h2>

<ul>
<li><strong>Plugin</strong>: <a href="https://github.com/w0rp/ale">ale</a></li>
<li><strong>Tool</strong>: <code>stack install hlint</code></li>
<li><strong>Tool</strong>: <code>stack build ghc-mod</code></li>
</ul>


<p>This is where the Neovim dependency starts to creep up, though Vim 8 is an
acceptable alternative for now. ALE stands for &ldquo;Asynchronous Lint Engine.&rdquo; It&rsquo;s
like Syntastic, but asynchronous<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup>.</p>

<p>There are a number of Haskell engines that ship with ALE. For example, it will
be able to show errors if all that&rsquo;s installed is Stack. My preferred tools to
use for Haskell with ALE are <code>hlint</code> and <code>ghc-mod</code>.</p>

<ul>
<li><code>hlint</code> is a linter for Haskell. It warns about silly things like <code>if x then
True else False</code>.</li>
<li><code>ghc-mod</code> is a tool that can check files for compiler errors</li>
</ul>


<p>Note that we want to <strong>stack build</strong> ghc-mod, not stack install it. The former
ensures that <code>ghc-mod</code> is local to the current stack project, so that the
version never gets out of sync with your project.</p>

<p>Once we&rsquo;ve installed all these programs, the setup is minimal. We&rsquo;ll be able to
see <code>hlint</code> and <code>ghc-mod</code> errors in our quickfix window right away.</p>

<figure class='code'><figcaption><span>ALE setup</span></figcaption><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='vim'><span class='line'><span class="k">let</span> <span class="nv">g:ale_linters</span><span class="p">.</span>haskell <span class="p">=</span> <span class="p">[</span><span class="s1">'stack-ghc-mod'</span><span class="p">,</span> <span class="s1">'hlint'</span><span class="p">]</span></span></code></pre></td></tr></table></div></figure>


<h2>Intero: The Pièce de Résistance</h2>

<ul>
<li><strong>Plugin</strong>: <a href="https://github.com/parsonsmatt/intero-neovim">intero-neovim</a></li>
</ul>


<p>Intero is a complete development program for Haskell. Probably the best way to
introduce it is with this asciicast:</p>

<p align="center">
  <a href="https://asciinema.org/a/128416">
    <img
      width="700px"
      alt="Intero for Neovim asciicast"
      src="https://asciinema.org/a/128416.png">
  </a>
</p>


<p>Intero is designed for stack, sets itself up automatically, has point-and-click
type information, and lets you jump to definitions. On top of it all, it uses
Neovim to communicate back and forth with a terminal buffer so that you get a
GHCi buffer <strong>right inside Neovim</strong>.</p>

<p>Developing with the REPL in mind helps me write code better. Only top-level
bindings are exposed in the REPL, so I write more small, testable functions.
See here for more reasons <a href="http://chrisdone.com/posts/haskell-repl">why the REPL is awesome</a>.</p>

<p>On top of providing access to the REPL, Intero provides about a dozen
convenience commands that shell out to the REPL backend. Being able to reload
your code in the REPL&mdash;from Vim, with a single keystroke!&mdash;is a huge boon when
developing.</p>

<p>Intero sets up no mappings by default, so here are mine. I also flip two config
variables to make Intero a little faster:</p>

<figure class='code'><figcaption><span>Intero settings</span></figcaption><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='vim'><span class='line'><span class="c">" Prefer starting Intero manually (faster startup times)</span>
</span><span class='line'><span class="k">let</span> <span class="nv">g:intero_start_immediately</span> <span class="p">=</span> <span class="m">0</span>
</span><span class='line'><span class="c">" Use ALE (works even when not using Intero)</span>
</span><span class='line'><span class="k">let</span> <span class="nv">g:intero_use_neomake</span> <span class="p">=</span> <span class="m">0</span>
</span><span class='line'>
</span><span class='line'>augroup interoMaps
</span><span class='line'>  <span class="k">au</span><span class="p">!</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">au</span> <span class="nb">FileType</span> haskell nnoremap <span class="p">&lt;</span><span class="k">silent</span><span class="p">&gt;</span> <span class="p">&lt;</span>leader<span class="p">&gt;</span>io <span class="p">:</span>InteroOpen<span class="p">&lt;</span>CR<span class="p">&gt;</span>
</span><span class='line'>  <span class="k">au</span> <span class="nb">FileType</span> haskell nnoremap <span class="p">&lt;</span><span class="k">silent</span><span class="p">&gt;</span> <span class="p">&lt;</span>leader<span class="p">&gt;</span>iov <span class="p">:</span>InteroOpen<span class="p">&lt;</span>CR<span class="p">&gt;&lt;</span>C<span class="p">-</span>W<span class="p">&gt;</span>H
</span><span class='line'>  <span class="k">au</span> <span class="nb">FileType</span> haskell nnoremap <span class="p">&lt;</span><span class="k">silent</span><span class="p">&gt;</span> <span class="p">&lt;</span>leader<span class="p">&gt;</span>ih <span class="p">:</span>InteroHide<span class="p">&lt;</span>CR<span class="p">&gt;</span>
</span><span class='line'>  <span class="k">au</span> <span class="nb">FileType</span> haskell nnoremap <span class="p">&lt;</span><span class="k">silent</span><span class="p">&gt;</span> <span class="p">&lt;</span>leader<span class="p">&gt;</span><span class="k">is</span> <span class="p">:</span>InteroStart<span class="p">&lt;</span>CR<span class="p">&gt;</span>
</span><span class='line'>  <span class="k">au</span> <span class="nb">FileType</span> haskell nnoremap <span class="p">&lt;</span><span class="k">silent</span><span class="p">&gt;</span> <span class="p">&lt;</span>leader<span class="p">&gt;</span>ik <span class="p">:</span>InteroKill<span class="p">&lt;</span>CR<span class="p">&gt;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">au</span> <span class="nb">FileType</span> haskell nnoremap <span class="p">&lt;</span><span class="k">silent</span><span class="p">&gt;</span> <span class="p">&lt;</span>leader<span class="p">&gt;</span>wr <span class="p">:</span><span class="k">w</span> \<span class="p">|</span> <span class="p">:</span>InteroReload<span class="p">&lt;</span>CR<span class="p">&gt;</span>
</span><span class='line'>  <span class="k">au</span> <span class="nb">FileType</span> haskell nnoremap <span class="p">&lt;</span><span class="k">silent</span><span class="p">&gt;</span> <span class="p">&lt;</span>leader<span class="p">&gt;</span><span class="k">il</span> <span class="p">:</span>InteroLoadCurrentModule<span class="p">&lt;</span>CR<span class="p">&gt;</span>
</span><span class='line'>  <span class="k">au</span> <span class="nb">FileType</span> haskell nnoremap <span class="p">&lt;</span><span class="k">silent</span><span class="p">&gt;</span> <span class="p">&lt;</span>leader<span class="p">&gt;</span><span class="k">if</span> <span class="p">:</span>InteroLoadCurrentFile<span class="p">&lt;</span>CR<span class="p">&gt;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">au</span> <span class="nb">FileType</span> haskell map <span class="p">&lt;</span>leader<span class="p">&gt;</span><span class="k">t</span> <span class="p">&lt;</span>Plug<span class="p">&gt;</span>InteroGenericType
</span><span class='line'>  <span class="k">au</span> <span class="nb">FileType</span> haskell map <span class="p">&lt;</span>leader<span class="p">&gt;</span>T <span class="p">&lt;</span>Plug<span class="p">&gt;</span>InteroType
</span><span class='line'>  <span class="k">au</span> <span class="nb">FileType</span> haskell nnoremap <span class="p">&lt;</span><span class="k">silent</span><span class="p">&gt;</span> <span class="p">&lt;</span>leader<span class="p">&gt;</span>it <span class="p">:</span>InteroTypeInsert<span class="p">&lt;</span>CR<span class="p">&gt;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">au</span> <span class="nb">FileType</span> haskell nnoremap <span class="p">&lt;</span><span class="k">silent</span><span class="p">&gt;</span> <span class="p">&lt;</span>leader<span class="p">&gt;</span>jd <span class="p">:</span>InteroGoToDef<span class="p">&lt;</span>CR<span class="p">&gt;</span>
</span><span class='line'>  <span class="k">au</span> <span class="nb">FileType</span> haskell nnoremap <span class="p">&lt;</span><span class="k">silent</span><span class="p">&gt;</span> <span class="p">&lt;</span>leader<span class="p">&gt;</span>iu <span class="p">:</span>InteroUses<span class="p">&lt;</span>CR<span class="p">&gt;</span>
</span><span class='line'>  <span class="k">au</span> <span class="nb">FileType</span> haskell nnoremap <span class="p">&lt;</span>leader<span class="p">&gt;</span>ist <span class="p">:</span>InteroSetTargets<span class="p">&lt;</span>SPACE<span class="p">&gt;</span>
</span><span class='line'>augroup END</span></code></pre></td></tr></table></div></figure>


<p>Intero takes a little getting used to, so be sure to read the docs for some
sample workflows.</p>

<h2>Wrap Up</h2>

<p>With these tools, I feel empowered rather than hindered when I sit down to write
some Haskell.</p>

<ul>
<li>It uses Stack whenever possible, so things Just Work.

<ul>
<li>As a consequence, this means all these plugins work with the implicit global
Stack project!</li>
</ul>
</li>
<li>It scales up in power:

<ul>
<li>from simple syntax highlighting to a <strong>REPL in the editor</strong>!</li>
<li>from manual indentation to an indentation sledgehammer</li>
</ul>
</li>
</ul>


<hr />

<h3>Jake on the Web</h3>

<p><a class="image-link" href="https://avatars5.githubusercontent.com/u/5544532?v=4&u=4640ad0fd7da51dc2a84c5ae9d11a96677b4d185&s=400"><img class="left" src="https://avatars5.githubusercontent.com/u/5544532?v=4&u=4640ad0fd7da51dc2a84c5ae9d11a96677b4d185&s=400" width="135" height="135"></a>
If you cared enough to read that far, you should consider following me on
<a href="https://www.github.com/jez/">GitHub</a> or paying a visit to <a href="https://jez.io/">my homepage</a>. If this post was about one of
my open source projects, make sure to star it on GitHub! I love hearing what
people think, so feel free to open an issue or send me an email.</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Tip: sometimes it&rsquo;s handy for <a href="https://github.com/commercialhaskell/stack/blob/3d29b8c/doc/faq.md#why-doesnt-stack-rebuild-my-project-when-i-specify---ghc-options-on-the-command-line">force a complete recompile</a>.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>If you still aren&rsquo;t convinced, the <a href="https://github.com/neovim/neovim#readme">Neovim logo</a> makes for a much better laptop sticker than Vim&rsquo;s.<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p>While listed under &ldquo;neovimhaskell&rdquo; on GitHub, this plugin works with normal Vim, too.<a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
<li id="fn:4">
<p>Chris Done explains the appeal of solving style issues with tooling for Haskell well. The moral of the story is that hindent version 5 ships with only the most popular style formatter in an effort to arrive at a singular Haskell style: <a href="http://chrisdone.com/posts/hindent-5">http://chrisdone.com/posts/hindent-5</a><a href="#fnref:4" rev="footnote">&#8617;</a></p></li>
<li id="fn:5">
<p>Some people are familiar with Neomake for this task. However, Neomake is much more minimal than ALE. Neomake basically only builds, whereas ALE is more configurable and hackable.<a href="#fnref:5" rev="footnote">&#8617;</a></p></li>
</ol>
</div>


      <footer class="entry-meta">
        <span class="entry-tags"><a href="/categories/#haskell" title="Pages tagged haskell" class="tag">haskell</a><a href="/categories/#vim" title="Pages tagged vim" class="tag">vim</a></span>
        <span><a href="/2017/07/16/haskell-development-with-neovim/" rel="bookmark" title="Haskell Development with Neovim">Haskell Development with Neovim</a> was published on <span class="entry-date date published updated"><time datetime="2017-07-16T14:45:31-04:00">July 16, 2017</time></span></span>
        
        <span class="author vcard"><span class="fn"><a href="https://jez.io" title="About Jake Zimmerman">Jake Zimmerman</a></span></span>
        
      </footer>
    </div><!-- /.entry-content -->
    
      <div class="read-more">
        
          <div class="read-more-header">
            <a href="/2017/02/26/reach-for-markdown-not-latex/" class="btn">Read More</a>
          </div><!-- /.read-more-header -->
          <div class="read-more-content">
            <h3><a href="/2017/02/26/reach-for-markdown-not-latex/" title="Reach for Markdown, not LaTeX">Reach for Markdown, not LaTeX</a></h3>
            <p>Writing should be a pleasant experience. With the right tools, it can be. LaTeX is powerful but cumbersome to use. With Markdown, we can focus on our writing, and worry about the presentation later. Pandoc can take care of the presentation for us, so the only thing left to do is start.
 <a href="/2017/02/26/reach-for-markdown-not-latex/"> Continue reading</a></p>
          </div><!-- /.read-more-content -->
        
        <div class="read-more-list">
          
            <div class="list-item">
              <h4><a href="/2016/08/03/troubleshooting-haskell-stack-setup-on-os-x/" title="Troubleshooting Haskell Stack Setup on OS X">Troubleshooting Haskell Stack Setup on OS X</a></h4>
              <span>Published on August 03, 2016</span>
            </div><!-- /.list-item -->
          
            <div class="list-item">
              <h4><a href="/2016/04/17/lets-have-a-chat-about-encryption/" title="Let's Have a Chat about Encryption">Let&#8217;s Have a Chat about Encryption</a></h4>
              <span>Published on April 17, 2016</span>
            </div><!-- /.list-item -->
          
        </div><!-- /.read-more-list -->
      </div><!-- /.read-more -->
    
    
  </article>
</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2017 Jake Zimmerman. Powered by <a href="http://octopress.org">Octopress</a> using the <a href="https://github.com/jez/hpstr-theme/">HPSTR Theme for Octopress</a>.</span>

  </footer>
</div><!-- /.footer-wrapper -->


	        
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="/javascripts/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="/javascripts/scripts.min.js"></script>
&#8211;>
	        

</body>
</html>


<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->

<head>


<meta charset="utf-8">
<meta http-equiv="cleartype" content="on">

<title>JavaScript, Union Types, and Optimizing Compilers - Bits, Bytes, and Words</title>
<meta name="author" content="Jake Zimmerman">




<meta name="description" content="Union types are a powerful tool and often overlooked. At work we use Flow, which thankfully supports union types. But as I refactor certain code &hellip;">

<meta name="keywords" content="flow javascript reasonml types ">


<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Twitter Cards -->


<!-- Open Graph -->
<meta property="og:local" content="en_US">
<meta property="og:type" content="article">
<meta property="og:url" content="https://blog.jez.io/js-union-types-opt">
<meta property="og:title" content="JavaScript, Union Types, and Optimizing Compilers">
<meta property="og:description" content="Union types are a powerful tool and often overlooked. At work we use Flow, which thankfully supports union types. But as I refactor certain code &hellip;">

  <meta property="og:image" content="">

<meta property="og:site_name" content="Bits, Bytes, and Words">

<link rel="canonical" href="https://blog.jez.io/js-union-types-opt">
<link href="/favicon.png" rel="icon">
<link href="/fonts/concourse.css" rel="stylesheet">
<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
<link href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">
<link href="/atom.xml" rel="alternate" title="Bits, Bytes, and Words" type="application/atom+xml">

<script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>
<script>Modernizr || document.write('<script src="/javascripts/vendor/modernizr-2.6.2.custom.min.js"><\/script>') </script>







</head>

<body id="post" class="">

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
<nav id="dl-menu" class="dl-menuwrapper" role="navigation">
  <button class="dl-trigger">Open Menu</button>
  <ul class="dl-menu">
    <li><a href="/">All Posts</a></li><li><a href="/categories#fragment">Fragments</a></li><li><a href="/categories/">Posts by Category</a></li><li><a href="https://jez.io">About Jake</a></li><li><a href="https://github.com/jez">GitHub</a></li>
  </ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->




<div id="main" role="main">
  <article class="hentry">
    <header class="header-title">
      <div class="header-title-wrap">
        
          <h1 class="entry-title">JavaScript, Union Types, and Optimizing Compilers</h1>
        
        <h2>April 19, 2018</h2>
        
      </div><!-- /.header-title-wrap -->
    </header>
    <div class="entry-content">
      <p>Union types are a powerful tool which is often overlooked. At work I&rsquo;ve
been using Flow, which thankfully supports union types. As I&rsquo;ve
refactored more of our code to use union types, I&rsquo;ve noticed that our
bundle size has been steadily increasing!</p>

<p>In this post, we&rsquo;re going to explore why that&rsquo;s the case. We&rsquo;ll start
with a problem which union types can solve, flesh out the problem to
motivate why union types are definitely the solution, then examine the
resulting cost of introducing them. In the end, we&rsquo;ll compare Flow to
other compile-to-JS languages on the basis of how they represent union
types in the compiled output. I&rsquo;m especially excited about <a href="https://reasonml.github.io/">Reason</a>, so
we&rsquo;ll talk about it the most.</p>

<h2>Setup: Union Types in a React Component</h2>

<p>Let&rsquo;s consider we&rsquo;re writing a simple React 2FA<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> modal.
We&rsquo;ll be using Flow, but you can pretend it&rsquo;s TypeScript if you want.
The mockup we were given looks like this:</p>

<p><a href="/images/2fa-mockup.jpeg"><img src="/images/2fa-mockup.jpeg" alt="A sample mockup for a two-factor authenticaion modal" /></a></p>

<p>Some things we notice from this mockup:</p>

<ul>
<li>There&rsquo;s a loading state while we send the text message.</li>
<li>We&rsquo;ll show an input to get the code after it&rsquo;s been sent.</li>
<li>There&rsquo;s no failure screen (it hasn&rsquo;t been drawn up yet).</li>
</ul>


<p>We&rsquo;ll need some way for our component to know which of the three screens
is visible. Let&rsquo;s use a <a href="https://flow.org/en/docs/types/unions/">union type</a> in Flow:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">type</span> <span class="nx">Screen</span> <span class="o">=</span>
</span><span class='line'>  <span class="o">|</span> <span class="s1">'LoadingScreen'</span>
</span><span class='line'>  <span class="o">|</span> <span class="s1">'CodeEntryScreen'</span>
</span><span class='line'>  <span class="o">|</span> <span class="s1">'SuccessScreen'</span><span class="p">;</span></span></code></pre></td></tr></table></div></figure>


<p>Union types are a perfect fit! 🎉  Union types document intent and can
help guard against mistakes. Fellow developers and your compiler can
know &ldquo;these are all the cases.&rdquo; In particular, Flow can warn you when
you&rsquo;ve <a href="/flow-exhaustiveness/">forotten a case</a>.</p>

<p>Our initial implementation is working great. After sharing it with the
team, someone suggests adding a &ldquo;cancel&rdquo; button in the top corner. It
doesn&rsquo;t make sense to cancel when the flow has already succeeded, so
we&rsquo;ll exclude it from the last screen (i.e., <code>'SuccessScreen'</code>):</p>

<p><a href="/images/2fa-close-btn.jpeg"><img src="/images/2fa-close-btn.jpeg" alt="Adding a close button to our modal" /></a></p>

<p>No problem: let&rsquo;s write a function called <code>needsCancelButton</code> to
determine if a we need to put a cancel button in the header for a
particular screen:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kr">const</span> <span class="nx">needsCancelButton</span> <span class="o">=</span> <span class="p">(</span><span class="nx">screen</span><span class="p">:</span> <span class="nx">Screen</span><span class="p">):</span> <span class="kr">boolean</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// Recall: 'SuccessScreen' is final, so it doesn't</span>
</span><span class='line'>  <span class="c1">// make sense to have a cancel button.</span>
</span><span class='line'>  <span class="k">return</span> <span class="nx">screen</span> <span class="o">!==</span> <span class="s1">'SuccessScreen'</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span></span></code></pre></td></tr></table></div></figure>


<p>Short and sweet. 👌 Everything seems to be working great, until&hellip;</p>

<h2><code>switch</code>: Optimizing for Exhaustiveness</h2>

<p>The next day, we get some updated mocks from the design team. This time,
they&rsquo;ve also drawn up a &ldquo;failure&rdquo; screen for when the customer has
entered the wrong code too many times:</p>

<p><a href="/images/2fa-failure-screen.jpeg"><img src="/images/2fa-failure-screen.jpeg" alt="The failure screen for our modal" /></a></p>

<p>We can handle this&mdash;we&rsquo;ll just add a case to our <code>Screen</code> type:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">type</span> <span class="nx">Screen</span> <span class="o">=</span>
</span><span class='line'>  <span class="o">|</span> <span class="s1">'LoadingScreen'</span>
</span><span class='line'>  <span class="o">|</span> <span class="s1">'CodeEntryScreen'</span>
</span><span class='line'>  <span class="o">|</span> <span class="s1">'SuccessScreen'</span>
</span><span class='line'>  <span class="c1">// New case to handle too many wrong attempts:</span>
</span><span class='line'>  <span class="o">|</span> <span class="s1">'FailureScreen'</span><span class="p">;</span></span></code></pre></td></tr></table></div></figure>


<p>But now there&rsquo;s a bug in our <code>needsCancelButton</code> function. 😧 We should
only show a close button on screens where it makes sense, and
<code>'FailureScreen'</code> is not one of those screens.</p>

<p>Our first reaction after discovering the bug would be to just blacklist
<code>'FailureScreen'</code> too:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kr">const</span> <span class="nx">needsCancelButton</span> <span class="o">=</span> <span class="p">(</span><span class="nx">screen</span><span class="p">:</span> <span class="nx">Screen</span><span class="p">):</span> <span class="kr">boolean</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="p">(</span>
</span><span class='line'>    <span class="nx">screen</span> <span class="o">!==</span> <span class="s1">'SuccessScreen'</span> <span class="o">||</span>
</span><span class='line'>    <span class="nx">screen</span> <span class="o">!==</span> <span class="s1">'FailureScreen'</span>
</span><span class='line'>  <span class="p">);</span>
</span><span class='line'><span class="p">};</span></span></code></pre></td></tr></table></div></figure>


<p>But we can do better. We should hold ourselves to the standard that when
we add a new case to a union type, our type checker <strong>always</strong> complains
when we haven&rsquo;t updated our logic to cover the additional case. What if
instead of a silent bug, we got this cheery message from our type
checker?</p>

<blockquote><p>Hey, you forgot to add a case to <code>needsCancelButton</code> for the new
screen you added. <em>🙂</em></p>

<p>&mdash; your friendly, neighborhood type checker</p></blockquote>

<p>Let&rsquo;s go back and rewrite <code>needsCancelButton</code> so that it <strong>will</strong> tell
us this when adding new cases. We&rsquo;ll use a <code>switch</code> statement with
<a href="/flow-exhaustiveness/">something special in the <code>default</code> case</a>:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kr">const</span> <span class="nx">impossible</span> <span class="o">=</span> <span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="nx">empty</span><span class="p">):</span> <span class="nx">T</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">'This case is impossible.'</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kr">const</span> <span class="nx">needsCancelButton</span> <span class="o">=</span> <span class="p">(</span><span class="na">screen</span><span class="p">:</span> <span class="nx">Screen</span><span class="p">):</span> <span class="kr">boolean</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">switch</span> <span class="p">(</span><span class="nx">screen</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="s1">'LoadingScreen'</span><span class="p">:</span>
</span><span class='line'>      <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span><span class='line'>    <span class="k">case</span> <span class="s1">'CodeEntryScreen'</span><span class="p">:</span>
</span><span class='line'>      <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span><span class='line'>    <span class="k">case</span> <span class="s1">'SuccessScreen'</span><span class="p">:</span>
</span><span class='line'>      <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
</span><span class='line'>    <span class="c1">// Uncomment to fix the Flow error</span>
</span><span class='line'>    <span class="c1">// case 'FailureScreen':</span>
</span><span class='line'>    <span class="c1">//   return false;</span>
</span><span class='line'>    <span class="nl">default</span><span class="p">:</span>
</span><span class='line'>      <span class="c1">// (I named this function 'absurd' in my previous blog post:</span>
</span><span class='line'>      <span class="c1">// https://blog.jez.io/flow-exhaustivness/)</span>
</span><span class='line'>      <span class="c1">// This function is here to ask Flow to check for exhaustiveness.</span>
</span><span class='line'>      <span class="c1">//</span>
</span><span class='line'>      <span class="c1">// [flow]: Error: Cannot call `impossible` with `screen` bound to `x` because string literal `FailureScreen` [1] is incompatible with empty [2].</span>
</span><span class='line'>      <span class="k">return</span> <span class="nx">impossible</span><span class="p">(</span><span class="nx">screen</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span></span></code></pre></td></tr></table></div></figure>


<p><a href="https://flow.org/try/#0PTAEAEDMBsHsHcBQiAuBPADgU1AZQMYBOWWAdqALyKigA+oA5ADKwCGAJgJakDmBxZBtTqMAwrHZYAoqRSE0-EqSE16DXAFd8+LAGddiwcLUAxVp2gbih5QG5k+WKV0pQnALYZY+zgCNoOBSgADwAKgB8ABQAHgBcoFie6ACU8aGU4aAA3sIoABaECKCkWPCgUoSFhJEMoXmcuqD4rLo4DW6e3rp+AQB0DMn2AL4OTi7FJOy6oqykOtAAQhooKE6UoJG6RErxNqmgvrCwAbMZ2cK68Jwo+HkbWwKkyec0NM2tjCwc3HzbgrHCV6gYgoKzkOQaLD2IHvHAMcSSGRyBR-ZQAoE0EFg0AQqGApotOGabR6AyohjojFYwjkSCsaCtaGvECgACqc1g7ncZFcq1AkE40RxeRwJjgZSwlVghHxLNhjDMFisWBsFNlYGBWFBNP59MZ+MkdI00BQlKB1PIHi8Pn8WE2qMGwhGQyAA"><strong>(Play with it on Try Flow →)</strong></a></p>

<p>Now Flow is smart enough to give us an error! Making our code safer, one
<code>switch</code> statement at a time. 😅 Union types in Flow are a powerful way
to use types to guarantee correctness. But to get the most out of union
types, <strong>only<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> ever access them</strong> through a <code>switch</code> statement.
Every time you use a union type without an exhaustive switch statement,
you make it harder for Flow to tell you where you&rsquo;ve missing something.</p>

<h2>Correctness, but at what cost?</h2>

<p>You might not have noticed, but we paid a subtle cost in rewriting
our <code>needsCancelButton</code> function. Let&rsquo;s compare our two functions:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'>
</span><span class='line'><span class="c1">// ----- before: 62 bytes (minified) -----</span>
</span><span class='line'>
</span><span class='line'><span class="kr">const</span> <span class="nx">needsCancelButton</span> <span class="o">=</span> <span class="p">(</span><span class="nx">screen</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="nx">screen</span> <span class="o">!==</span> <span class="s1">'SuccessScreen'</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// ----- after: 240 bytes (minified) -----</span>
</span><span class='line'>
</span><span class='line'><span class="kr">const</span> <span class="nx">impossible</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">'This case is impossible.'</span><span class="p">);</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kr">const</span> <span class="nx">needsCancelButton</span> <span class="o">=</span> <span class="p">(</span><span class="nx">screen</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">switch</span> <span class="p">(</span><span class="nx">screen</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="s1">'LoadingScreen'</span><span class="p">:</span>
</span><span class='line'>      <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span><span class='line'>    <span class="k">case</span> <span class="s1">'CodeEntryScreen'</span><span class="p">:</span>
</span><span class='line'>      <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span><span class='line'>    <span class="k">case</span> <span class="s1">'SuccessScreen'</span><span class="p">:</span>
</span><span class='line'>      <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
</span><span class='line'>    <span class="nl">default</span><span class="p">:</span>
</span><span class='line'>      <span class="k">return</span> <span class="nx">impossible</span><span class="p">(</span><span class="nx">screen</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span></span></code></pre></td></tr></table></div></figure>


<p>With just an <code>if</code> statement, our function was quite small: 62 bytes
minified. But when we refactored to use a <code>switch</code> statement, its size
shot up to 240 bytes! That&rsquo;s a 4x increase, just to get exhaustiveness.
Admittedly, <code>needsCancelButton</code> is a bit of a pathological case. But in
general: as we make our code bases <strong>more safe</strong> using Flow&rsquo;s union
types of string literals, our <strong>bundle size bloats</strong>!</p>

<h2>Types and Optimizing Compilers</h2>

<p>One of the many overlooked promises of types is the claim that by
writing our code with <strong>higher-level abstractions</strong>, we give more
information to the compiler. The compiler can then generate code that
captures our original intent, but as efficiently as possible.</p>

<p>Flow is decidedly <strong>not</strong> a compiler: it&rsquo;s only a type checker. To run
JavaScript annotated with Flow types, we first strip the types (with
something like Babel). All information about the types is lost
when we run the code.<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup> What can we achieve if we were to
<strong>keep the types around</strong> all the way through compilation?</p>

<p><a href="https://reasonml.github.io/">Reason</a> (i.e., ReasonML) is an exciting effort to bring all the
benefits of the OCaml tool chain to the web. In particular, Reason
works using OCaml&rsquo;s very mature optimizing compiler alongside
BuckleScript (which turns OCaml to JavaScript) to emit great code.</p>

<p>To see what I mean, let&rsquo;s re-implement our <code>Screen</code> type and
<code>needsCancelButton</code> function, this time in Reason:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">type</span> <span class="nx">screen</span> <span class="o">=</span>
</span><span class='line'>  <span class="o">|</span> <span class="nx">LoadingScreen</span>
</span><span class='line'>  <span class="o">|</span> <span class="nx">CodeEntryScreen</span>
</span><span class='line'>  <span class="o">|</span> <span class="nx">SuccessScreen</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="kd">let</span> <span class="nx">needsCancelButton</span> <span class="o">=</span> <span class="p">(</span><span class="nx">screen</span><span class="p">:</span> <span class="nx">screen</span><span class="p">):</span> <span class="nx">bool</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">switch</span> <span class="p">(</span><span class="nx">screen</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="o">|</span> <span class="nx">LoadingScreen</span> <span class="o">=&gt;</span> <span class="kc">true</span><span class="p">;</span>
</span><span class='line'>  <span class="o">|</span> <span class="nx">CodeEntryScreen</span> <span class="o">=&gt;</span> <span class="kc">true</span><span class="p">;</span>
</span><span class='line'>  <span class="o">|</span> <span class="nx">SuccessScreen</span> <span class="o">=&gt;</span> <span class="kc">false</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span></span></code></pre></td></tr></table></div></figure>


<p>Looks pretty close to JavaScript with Flow types, doesn&rsquo;t it? The
biggest difference is that we the <code>case</code> keyword was replaced with the
<code>|</code> character. (This directly mirrors the definition of the <code>screen</code>
type&mdash;it&rsquo;s a nice reminder to always use <code>switch</code> statements when using
union types<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>). Another difference: Reason does
exhaustiveness checking out of the box!</p>

<p>What code does Reason output (via BuckleScript) for our function?</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="c1">// Generated by BUCKLESCRIPT VERSION 3.0.1, PLEASE EDIT WITH CARE</span>
</span><span class='line'><span class="s1">'use strict'</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="kd">function</span> <span class="nx">needsCancelButton</span><span class="p">(</span><span class="nx">status</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="nx">status</span> <span class="o">!==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span></span></code></pre></td></tr></table></div></figure>


<p><a href="https://reasonml.github.io/en/try.html?rrjsx=true&amp;reason=C4TwDgpgBAzgxgJwhAdlAvAKClAPlAGQHsBDAEwEsUBzAZUWRWzygGEiyIBRFYBEeklTN8tAK5w4EGDEGMA3JkwAbCMCgpkZGKxIopygEJjgwImnRQAFPCEoAXLAaoAlI4BGRIsowA+KADezDAA7hTAcAAW1raMLoEihKSUNHKoflB8YhCKOPjsnDx8As4W-lk5ieKS0rKlGQBmJMowlTgAvpjtikA"><strong>(Play with it on Try Reason →)</strong></a></p>

<p>Not bad! Telling Reason that our function was exhaustive let it optimize
the entire <code>switch</code> statement back down to a single <code>if</code> statement, like
we started with. In fact, it gets even better: when we run this through
<code>uglifyjs</code>, it removes the redundant <code>true</code> / <code>false</code>:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="s2">"use strict"</span><span class="p">;</span>
</span><span class='line'><span class="kd">function</span> <span class="nx">needsCancelButton</span><span class="p">(</span><span class="nx">n</span><span class="p">){</span>
</span><span class='line'>  <span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="nx">n</span><span class="o">&gt;=</span><span class="mi">2</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span></span></code></pre></td></tr></table></div></figure>


<p>Wow! This is actually <strong>better</strong> than our initial, hand-written <code>if</code>
statement. Reason compiled what used to be a string literal
<code>'SuccessScreen'</code> to just the number <code>2</code>. Reason can do this safely
because custom-defined types in Reason <strong>can&rsquo;t</strong> be treated like
strings, so it doesn&rsquo;t matter if you mangle the names.</p>

<p>Taking a step back, Reason&rsquo;s type system delivered on the promise of
types in a way Flow couldn&rsquo;t:</p>

<ul>
<li>We wrote high-level, expressive code.</li>
<li>The type checker gave us strong guarantees about the correctness
(exhaustiveness) of our code.</li>
<li>And the compiler translated that all to tiny, performant code.</li>
</ul>


<p>I&rsquo;m really excited about Reason. 😄 It has a delightful type system and
is backed by a decades-old optimizing compiler tool chain. I&rsquo;d love to
see more people take advantage of improvements in type systems to write
better code!</p>

<hr />

<h2>Appendix: Other Compile-to-JS Runtimes</h2>

<p>The above analysis only considered Flow + Babel and Reason. But then I
got curious about how other typed languages that compile to JavaScript
compare on the optimizations front:</p>

<h3>TypeScript</h3>

<p>Despite being a language <strong>and</strong> compiler, TypeScript maintains a
goal of compiling to JavaScript that closely resembles the source
TypesScript code. TypeScript also has two language constructs for
working with exhaustiveness:</p>

<ul>
<li>union types, analogous to what Flow has, and</li>
<li><code>enum</code>s, which are basically like Java&rsquo;s <code>enum</code>s.</li>
</ul>


<p>With union types, TypeScript behaves basically the same as Flow 🙁. But
what was surprising: <code>enum</code>s compressed <strong>even worse</strong>:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">var</span> <span class="nx">Screen_</span><span class="p">;</span>
</span><span class='line'><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">Screen_</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">Screen_</span><span class="p">[</span><span class="nx">Screen_</span><span class="p">[</span><span class="s2">"LoadingScreen"</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"LoadingScreen"</span><span class="p">;</span>
</span><span class='line'>    <span class="nx">Screen_</span><span class="p">[</span><span class="nx">Screen_</span><span class="p">[</span><span class="s2">"CodeEntryScreen"</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"CodeEntryScreen"</span><span class="p">;</span>
</span><span class='line'>    <span class="nx">Screen_</span><span class="p">[</span><span class="nx">Screen_</span><span class="p">[</span><span class="s2">"SuccessScreen"</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"SuccessScreen"</span><span class="p">;</span>
</span><span class='line'><span class="p">})(</span><span class="nx">Screen_</span> <span class="o">||</span> <span class="p">(</span><span class="nx">Screen_</span> <span class="o">=</span> <span class="p">{}));</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">impossible</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">'This case is impossible.'</span><span class="p">);</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">needsCancelButton</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">screen</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">switch</span> <span class="p">(</span><span class="nx">screen</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">case</span> <span class="nx">Screen_</span><span class="p">.</span><span class="nx">LoadingScreen</span><span class="p">:</span>
</span><span class='line'>            <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span><span class='line'>        <span class="k">case</span> <span class="nx">Screen_</span><span class="p">.</span><span class="nx">CodeEntryScreen</span><span class="p">:</span>
</span><span class='line'>            <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span><span class='line'>        <span class="k">case</span> <span class="nx">Screen_</span><span class="p">.</span><span class="nx">SuccessScreen</span><span class="p">:</span>
</span><span class='line'>            <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
</span><span class='line'>        <span class="nl">default</span><span class="p">:</span>
</span><span class='line'>            <span class="k">return</span> <span class="nx">impossible</span><span class="p">(</span><span class="nx">screen</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span></span></code></pre></td></tr></table></div></figure>


<p><a href="https://www.typescriptlang.org/play/#src=enum%20Screen_%20%7B%0D%0A%20%20%20%20LoadingScreen%2C%0D%0A%20%20%20%20CodeEntryScreen%2C%0D%0A%20%20%20%20SuccessScreen%2C%0D%0A%7D%0D%0A%0D%0Aconst%20impossible%20%3D%20%3CT%3E(x%3A%20never)%3A%20T%20%3D%3E%20%7B%0D%0A%20%20throw%20new%20Error('This%20case%20is%20impossible.')%3B%0D%0A%7D%0D%0A%0D%0Aconst%20needsCancelButton%20%3D%20(screen%3A%20Screen_)%3A%20boolean%20%3D%3E%20%7B%0D%0A%20%20switch%20(screen)%20%7B%0D%0A%20%20%20%20case%20Screen_.LoadingScreen%3A%0D%0A%20%20%20%20%20%20return%20true%3B%0D%0A%20%20%20%20case%20Screen_.CodeEntryScreen%3A%0D%0A%20%20%20%20%20%20return%20true%3B%0D%0A%20%20%20%20case%20Screen_.SuccessScreen%3A%0D%0A%20%20%20%20%20%20return%20false%3B%0D%0A%20%20%20%20default%3A%0D%0A%20%20%20%20%20%20return%20impossible(screen)%3B%0D%0A%20%20%7D%0D%0A%7D"><strong>TypeScript Playground →</strong></a></p>

<ul>
<li>It&rsquo;s not smart enough to optimize away the <code>impossible</code> call.</li>
<li>It keeps around a JavaScript object representing the collection of
enum values at run time, in a format that doesn&rsquo;t minify well.</li>
</ul>


<h2>PureScript</h2>

<p>PureScript is another high-level language like Reason. They both have
data types where you can define unions with custom constructor names.
Despite that, PureScript&rsquo;s generated code is significantly worse than
Reason&rsquo;s.</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="s2">"use strict"</span><span class="p">;</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">LoadingScreen</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">function</span> <span class="nx">LoadingScreen</span><span class="p">()</span> <span class="p">{};</span>
</span><span class='line'>    <span class="nx">LoadingScreen</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">LoadingScreen</span><span class="p">();</span>
</span><span class='line'>    <span class="k">return</span> <span class="nx">LoadingScreen</span><span class="p">;</span>
</span><span class='line'><span class="p">})();</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">CodeEntryScreen</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">function</span> <span class="nx">CodeEntryScreen</span><span class="p">()</span> <span class="p">{};</span>
</span><span class='line'>    <span class="nx">CodeEntryScreen</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">CodeEntryScreen</span><span class="p">();</span>
</span><span class='line'>    <span class="k">return</span> <span class="nx">CodeEntryScreen</span><span class="p">;</span>
</span><span class='line'><span class="p">})();</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">SuccessScreen</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">function</span> <span class="nx">SuccessScreen</span><span class="p">()</span> <span class="p">{};</span>
</span><span class='line'>    <span class="nx">SuccessScreen</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">SuccessScreen</span><span class="p">();</span>
</span><span class='line'>    <span class="k">return</span> <span class="nx">SuccessScreen</span><span class="p">;</span>
</span><span class='line'><span class="p">})();</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">needsCancelButton</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="nx">v</span> <span class="k">instanceof</span> <span class="nx">LoadingScreen</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span><span class='line'>    <span class="p">};</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="nx">v</span> <span class="k">instanceof</span> <span class="nx">CodeEntryScreen</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span><span class='line'>    <span class="p">};</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="nx">v</span> <span class="k">instanceof</span> <span class="nx">SuccessScreen</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
</span><span class='line'>    <span class="p">};</span>
</span><span class='line'>    <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s2">"Failed pattern match at Main line 10, column 1 - line 10, column 39: "</span> <span class="o">+</span> <span class="p">[</span> <span class="nx">v</span><span class="p">.</span><span class="nx">constructor</span><span class="p">.</span><span class="nx">name</span> <span class="p">]);</span>
</span><span class='line'><span class="p">};</span></span></code></pre></td></tr></table></div></figure>


<ul>
<li>It&rsquo;s generating ES5 classes for each data constructor.</li>
<li>It compiles pattern matching to a series of <code>instanceof</code> checks.</li>
<li>Even though it <strong>knows</strong> the match is exhaustive, it still emits a
<code>throw</code> statement in case the pattern match fails!</li>
</ul>


<p>Admittedly, I didn&rsquo;t try that hard to turn on optimizations in the
compiler. Maybe there&rsquo;s a flag I can pass to get this <code>Error</code> to go
away. But that&rsquo;s pretty disappointing, compared to how small Reason&rsquo;s
generated code was!</p>

<h2>Elm</h2>

<p>I put Elm in the same class as Reason and PureScript. Like the other
two, it lets you define custom data types, and will automatically warn
when your pattern matches aren&rsquo;t exhaustive.</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">var</span> <span class="nx">_user$project$Main$needsCancelButton</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">page</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">_p0</span> <span class="o">=</span> <span class="nx">page</span><span class="p">;</span>
</span><span class='line'>  <span class="k">switch</span> <span class="p">(</span><span class="nx">_p0</span><span class="p">.</span><span class="nx">ctor</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">case</span> <span class="s1">'LoadingScreen'</span><span class="p">:</span>
</span><span class='line'>          <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span><span class='line'>      <span class="k">case</span> <span class="s1">'CodeEntryScreen'</span><span class="p">:</span>
</span><span class='line'>          <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span><span class='line'>      <span class="nl">default</span><span class="p">:</span>
</span><span class='line'>          <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">_user$project$Main$SuccessScreen</span> <span class="o">=</span> <span class="p">{</span><span class="na">ctor</span><span class="p">:</span> <span class="s1">'SuccessScreen'</span><span class="p">};</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">_user$project$Main$CodeEntryScreen</span> <span class="o">=</span> <span class="p">{</span><span class="na">ctor</span><span class="p">:</span> <span class="s1">'CodeEntryScreen'</span><span class="p">};</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">_user$project$Main$LoadingScreen</span> <span class="o">=</span> <span class="p">{</span><span class="na">ctor</span><span class="p">:</span> <span class="s1">'LoadingScreen'</span><span class="p">};</span></span></code></pre></td></tr></table></div></figure>


<ul>
<li>It&rsquo;s using string literals, much like Flow and TypeScript.</li>
<li>It&rsquo;s smart enough to collapse the last case to just use <code>default</code>
(at least it doesn&rsquo;t <code>throw</code> in the <code>default</code> case!)</li>
<li>The variable names are long, but these would still minify well.</li>
</ul>


<p>It&rsquo;s interesting to see that even though Reason, PureScript, and Elm all have ML-style datatypes, Reason is the only one that uses an integer representation for the constructor tags.</p>

<!-- vim:tw=72
-->

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>2FA: two-factor authentication<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>&ldquo;Only ever&rdquo; is a very strong statement. Please use your best judgement. But know that if you&rsquo;re not using a <code>switch</code>, you&rsquo;re trading off the burden of exhaustiveness &amp; correctness from the type checker to the programmer!<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p>Even though TypeScript defines both a language <strong>and</strong> a compiler for that language, in practice it&rsquo;s not much different from Flow here. A goal of the TypeScript compiler is to generate JavaScript that closely resembles the original TypeScript, so it doesn&rsquo;t do compile-time optimizations based on the types.<a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
<li id="fn:4">
<p>More than being a nice reminder, it makes it easy to copy / paste our type definition as boilerplate to start writing a new function!<a href="#fnref:4" rev="footnote">&#8617;</a></p></li>
</ol>
</div>


      <footer class="entry-meta">
        <span class="entry-tags"><a href="/categories/#flow" title="Pages tagged flow" class="tag">flow</a><a href="/categories/#javascript" title="Pages tagged javascript" class="tag">javascript</a><a href="/categories/#reasonml" title="Pages tagged reasonml" class="tag">reasonml</a><a href="/categories/#types" title="Pages tagged types" class="tag">types</a></span>
        <span class="entry-date date published updated"><time datetime="2018-04-19T01:43:26-04:00">April 19, 2018</time></span>
        
      </footer>
    </div><!-- /.entry-content -->
    
      <div class="read-more">
        
          <div class="read-more-header">
            <a href="/flow-exhaustiveness/" class="btn">Read More</a>
          </div><!-- /.read-more-header -->
          <div class="read-more-content">
            <h3><a href="/flow-exhaustiveness/" title="Case Exhaustiveness in Flow">Case Exhaustiveness in Flow</a></h3>
            <p>Compared to some other languages, Flow&#8217;s story around exhaustiveness checking within &#8216;if / else&#8217; and &#8216;switch&#8217; statements leaves something to be desired. By default, Flow doesn&#8217;t do any exhaustiveness checks! But we can opt-in to exhaustiveness checking one statement at a time. In this post, we&#8217;ll discover from the ground up how Flow&#8217;s exhaustiveness checking behaves.
 <a href="/flow-exhaustiveness/"> Continue reading</a></p>
          </div><!-- /.read-more-content -->
        
        <div class="read-more-list">
          
            <div class="list-item">
              <h4><a href="/lens-composition/" title="Lenses & Composition">Lenses & Composition</a></h4>
              <span>Published on February 06, 2018</span>
            </div><!-- /.list-item -->
          
            <div class="list-item">
              <h4><a href="/lens-intuition/" title="Some Intuition on Lenses">Some Intuition on Lenses</a></h4>
              <span>Published on February 06, 2018</span>
            </div><!-- /.list-item -->
          
        </div><!-- /.read-more-list -->
      </div><!-- /.read-more -->
    
    
  </article>
</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2018 Jake Zimmerman. Powered by <a href="http://octopress.org">Octopress</a> using the <a href="https://github.com/jez/hpstr-theme/">HPSTR Theme for Octopress</a>.</span>

  </footer>
</div><!-- /.footer-wrapper -->


	        
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="/javascripts/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="/javascripts/scripts.min.js"></script>
&#8211;>
	        

</body>
</html>
